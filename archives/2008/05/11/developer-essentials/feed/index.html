<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
		>
<channel>
	<title>Comments on: Developer Essentials</title>
	<atom:link href="http://girtby.net/archives/2008/05/11/developer-essentials/feed/" rel="self" type="application/rss+xml" />
	<link>http://girtby.net/archives/2008/05/11/developer-essentials/</link>
	<description>this blog is girtby.net</description>
	<lastBuildDate>Wed, 30 Sep 2009 01:44:34 -0400</lastBuildDate>
	<generator>http://wordpress.org/?v=2.9-rare</generator>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
		<item>
		<title>By: Gray Fox</title>
		<link>http://girtby.net/archives/2008/05/11/developer-essentials/comment-page-1/#comment-2799</link>
		<dc:creator>Gray Fox</dc:creator>
		<pubDate>Sat, 07 Mar 2009 02:31:24 +0000</pubDate>
		<guid isPermaLink="false">http://girtby.net/2008/05/15/developer-essentials#comment-2799</guid>
		<description>&lt;p&gt;I know C, and I feel no debt to it.  I learned Java first, then C, then VB.NET and PHP.  I know C is the father of many languages out there, but IT changes at an alarming rate, and thus why cling to the outmoded past.  Java was a great Introduction to programming.  C was onerous and cumbersome and not very sexy or exciting, but I still got As in those courses, so this is not a sour grapes post.  I am also an electrician, but I would not say that all new disciplines learn on the old Simpson 260 multimeter, or one of those old clunky Tektronics O-scopes.  Did the do the job?  Of course.  But have we not come a long way?  Have we not evolved?  Refined our techniques and approaches.  &lt;/p&gt;

&lt;p&gt;The idea that all new coders need to know C is as ludicrous as saying all new gamers need to know the Atari 2600.  And what would that prove?&lt;/p&gt;
</description>
		<content:encoded><![CDATA[<p>I know C, and I feel no debt to it.  I learned Java first, then C, then VB.NET and PHP.  I know C is the father of many languages out there, but IT changes at an alarming rate, and thus why cling to the outmoded past.  Java was a great Introduction to programming.  C was onerous and cumbersome and not very sexy or exciting, but I still got As in those courses, so this is not a sour grapes post.  I am also an electrician, but I would not say that all new disciplines learn on the old Simpson 260 multimeter, or one of those old clunky Tektronics O-scopes.  Did the do the job?  Of course.  But have we not come a long way?  Have we not evolved?  Refined our techniques and approaches.  </p>

<p>The idea that all new coders need to know C is as ludicrous as saying all new gamers need to know the Atari 2600.  And what would that prove?</p>]]></content:encoded>
	</item>
	<item>
		<title>By: Svarvsven</title>
		<link>http://girtby.net/archives/2008/05/11/developer-essentials/comment-page-1/#comment-1689</link>
		<dc:creator>Svarvsven</dc:creator>
		<pubDate>Sun, 11 May 2008 13:09:00 +0000</pubDate>
		<guid isPermaLink="false">http://girtby.net/2008/05/15/developer-essentials#comment-1689</guid>
		<description>&lt;ol&gt;
&lt;li&gt;C&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Well, before you settle down with any one language you should go out and try plenty of different flavours. Then later you can get married to one and make a number of little softwares with it.&lt;/p&gt;

&lt;p&gt;At least, thats what I would consider be part of &quot;skills that every developer should have&quot;.&lt;/p&gt;

&lt;p&gt;Of course, C is one of those languages one should take a really close look at. The similar ones like C++ and C# get at least some medium knowledge. Others like (Visual?)Basic, Pascal, F#, Lisp, Smalltalk, Ruby, Forth, Cobol there should be at least some curious interest in a few of those. And at least look in to one Assembly language (maybe even MSIL while you are at it).&lt;/p&gt;

&lt;p&gt;Single hardware platform without a C compiler? Heck, was probably about 20 years since I was writing software in Forth (in my spare time) but that community was really intersted in custom made Forth-native-CPUs. Google with &quot;Forth CPU&quot; and you find at least one. (yes, yes someone maybe did write some half attempt to C-compiler in Forth...does that really count?)&lt;/p&gt;
</description>
		<content:encoded><![CDATA[<ol>
<li>C</li>
</ol>

<p>Well, before you settle down with any one language you should go out and try plenty of different flavours. Then later you can get married to one and make a number of little softwares with it.</p>

<p>At least, thats what I would consider be part of &#8220;skills that every developer should have&#8221;.</p>

<p>Of course, C is one of those languages one should take a really close look at. The similar ones like C++ and C# get at least some medium knowledge. Others like (Visual?)Basic, Pascal, F#, Lisp, Smalltalk, Ruby, Forth, Cobol there should be at least some curious interest in a few of those. And at least look in to one Assembly language (maybe even MSIL while you are at it).</p>

<p>Single hardware platform without a C compiler? Heck, was probably about 20 years since I was writing software in Forth (in my spare time) but that community was really intersted in custom made Forth-native-CPUs. Google with &#8220;Forth CPU&#8221; and you find at least one. (yes, yes someone maybe did write some half attempt to C-compiler in Forth&#8230;does that really count?)</p>]]></content:encoded>
	</item>
	<item>
		<title>By: Alastair</title>
		<link>http://girtby.net/archives/2008/05/11/developer-essentials/comment-page-1/#comment-1690</link>
		<dc:creator>Alastair</dc:creator>
		<pubDate>Sun, 11 May 2008 13:09:00 +0000</pubDate>
		<guid isPermaLink="false">http://girtby.net/2008/05/15/developer-essentials#comment-1690</guid>
		<description>&lt;p&gt;Thanks for the comment Svarvsven, though I&#039;m not sure anyone really needs to get married (either literally or metaphorically) to a programming language, at least not monogamously.&lt;/p&gt;

&lt;p&gt;It&#039;s certainly essential for developers to have experience and knowledge of other languages &#8212; the more the better &#8212; but C is the one you can&#039;t do without. I don&#039;t think any of the languages you mentioned are a decent substitute for C if you had to learn just one.&lt;/p&gt;

&lt;p&gt;Good point about the Forth machines, I had forgotten about those. Doesn&#039;t change the point though.&lt;/p&gt;
</description>
		<content:encoded><![CDATA[<p>Thanks for the comment Svarvsven, though I&#8217;m not sure anyone really needs to get married (either literally or metaphorically) to a programming language, at least not monogamously.</p>

<p>It&#8217;s certainly essential for developers to have experience and knowledge of other languages &mdash; the more the better &mdash; but C is the one you can&#8217;t do without. I don&#8217;t think any of the languages you mentioned are a decent substitute for C if you had to learn just one.</p>

<p>Good point about the Forth machines, I had forgotten about those. Doesn&#8217;t change the point though.</p>]]></content:encoded>
	</item>
	<item>
		<title>By: Aristotle Pagaltzis</title>
		<link>http://girtby.net/archives/2008/05/11/developer-essentials/comment-page-1/#comment-1691</link>
		<dc:creator>Aristotle Pagaltzis</dc:creator>
		<pubDate>Sun, 11 May 2008 13:09:00 +0000</pubDate>
		<guid isPermaLink="false">http://girtby.net/2008/05/15/developer-essentials#comment-1691</guid>
		<description>&lt;p&gt;“&lt;code&gt;0x2022&lt;/code&gt;”‽ Only a philistine would write &lt;code&gt;U+2022&lt;/code&gt; that way.&lt;/p&gt;

&lt;p&gt;And C is indeed &lt;em&gt;the&lt;/em&gt; most portable language… for some values of “portable.” (Not that this takes away from the point you were making.)&lt;/p&gt;

&lt;p&gt;As for OO, I think it severely overrated. In fact, wanting to use OOD for &lt;em&gt;everything&lt;/em&gt; is the sign of an enterprisey Java weenie. If we are going to be discussing paradigms, then I would rather propose functional programming as essential; at least, it is vastly underrated at this time. I consider ignorance of closures and how to use them effectively, at minimum, a serious disgrace for any skilled developer. Thankfully this part of the arcana seems to be hitching a ride back into the collective consciousness on Javascript’s back. (Yay for “Ajax”!)&lt;/p&gt;

&lt;p&gt;I would also argue that a working knowledge of assembler is equally as important. Joel has &lt;a href=&quot;http://www.joelonsoftware.com/articles/fog0000000319.html&quot; title=&quot;Joel Spolsky: Back to Basics&quot;&gt;argued identically, if at a slightly higher level&lt;/a&gt;: you need to understand what the machine really does in order to understand which of the things you write are intrinsically expensive and why. Writing in a high-level language can make cheap things expensive, but it can never ever magically make expensive things cheap: in the end, it’s all machine code to the CPU. (High-level languages can make expensive things &lt;em&gt;seem&lt;/em&gt; cheaper by imposing a tax; that too you need to understand. Note that this is not a slight against high-level languages: when the tax money is spent well, you stand to gain a lot from paying it.)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;I don’t think any of the languages you mentioned are a decent substitute for C if you had to learn just one.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Actually, if one were forced to learn only one language, I would argue that C would absolutely be the wrong one. Sure you can do everything with a Turing machine, but when you’re stuck in a place where everything is possible but nothing of interest is easy, you might regret the choice. Someone who is going to remain as limited as a single-language programmer necessarily must be (which holds true even if their language is C) will be far more productive by concentrating on whichever high-level language best fits their particular goals. An office grunt in a Windows shop would probably be 100× better served with VBA than C, f.ex. They’re never going to become a serious developer, but without knowing a second language, &lt;em&gt;you cannot be&lt;/em&gt;.&lt;/p&gt;
</description>
		<content:encoded><![CDATA[<p>“<code>0x2022</code>”‽ Only a philistine would write <code>U+2022</code> that way.</p>

<p>And C is indeed <em>the</em> most portable language… for some values of “portable.” (Not that this takes away from the point you were making.)</p>

<p>As for OO, I think it severely overrated. In fact, wanting to use OOD for <em>everything</em> is the sign of an enterprisey Java weenie. If we are going to be discussing paradigms, then I would rather propose functional programming as essential; at least, it is vastly underrated at this time. I consider ignorance of closures and how to use them effectively, at minimum, a serious disgrace for any skilled developer. Thankfully this part of the arcana seems to be hitching a ride back into the collective consciousness on Javascript’s back. (Yay for “Ajax”!)</p>

<p>I would also argue that a working knowledge of assembler is equally as important. Joel has <a href="http://www.joelonsoftware.com/articles/fog0000000319.html" title="Joel Spolsky: Back to Basics">argued identically, if at a slightly higher level</a>: you need to understand what the machine really does in order to understand which of the things you write are intrinsically expensive and why. Writing in a high-level language can make cheap things expensive, but it can never ever magically make expensive things cheap: in the end, it’s all machine code to the CPU. (High-level languages can make expensive things <em>seem</em> cheaper by imposing a tax; that too you need to understand. Note that this is not a slight against high-level languages: when the tax money is spent well, you stand to gain a lot from paying it.)</p>

<blockquote>
  <p>I don’t think any of the languages you mentioned are a decent substitute for C if you had to learn just one.</p>
</blockquote>

<p>Actually, if one were forced to learn only one language, I would argue that C would absolutely be the wrong one. Sure you can do everything with a Turing machine, but when you’re stuck in a place where everything is possible but nothing of interest is easy, you might regret the choice. Someone who is going to remain as limited as a single-language programmer necessarily must be (which holds true even if their language is C) will be far more productive by concentrating on whichever high-level language best fits their particular goals. An office grunt in a Windows shop would probably be 100× better served with VBA than C, f.ex. They’re never going to become a serious developer, but without knowing a second language, <em>you cannot be</em>.</p>]]></content:encoded>
	</item>
	<item>
		<title>By: Alastair</title>
		<link>http://girtby.net/archives/2008/05/11/developer-essentials/comment-page-1/#comment-1692</link>
		<dc:creator>Alastair</dc:creator>
		<pubDate>Sun, 11 May 2008 13:09:00 +0000</pubDate>
		<guid isPermaLink="false">http://girtby.net/2008/05/15/developer-essentials#comment-1692</guid>
		<description>&lt;blockquote&gt;
  &lt;p&gt;“0x2022”‽ Only a philistine would write U+2022 that way.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I&#039;m going to claim typo, or possibly a thinko, on that. As demonstrated &lt;a href=&quot;/archives/2007/3/9/c-1-unicode-0&quot;&gt;previously&lt;/a&gt;, I am aware of the correct notation for code points.&lt;/p&gt;

&lt;p&gt;On C portability: it has to be said that in comparison to many other languages, C has a relatively poor standard library, so you often find yourself needing to use third-party libraries or specific system calls. Either way portability takes a hit. The same is true of all languages, but it is far more common in C.&lt;/p&gt;

&lt;p&gt;So the claim about C being the most portable of languages should perhaps be clarified thus: If you have a program written entirely in C using only the standard library, you&#039;ll be able to port it to a wider range of systems than for an equivalent program in any other language.&lt;/p&gt;

&lt;p&gt;I agree with all of your other points, although the line I drew for myself was more about practical experience than essential theoretical knowledge. And that&#039;s a somewhat blurry line obviously.&lt;/p&gt;

&lt;p&gt;I didn&#039;t mean to claim that it was acceptable to know only one language, just that C should be one of them.&lt;/p&gt;

&lt;p&gt;Jeff Atwood disclosed recently that he had &lt;a href=&quot;http://blog.stackoverflow.com/index.php/2008/04/podcast-2/&quot;&gt;never learned C&lt;/a&gt;. To me, this revelation is a profound hit to his credibility (and see a forthcoming blog article on that). It is like finding out that the chef who cooked your meal is a &lt;a href=&quot;http://en.wikipedia.org/wiki/The_30%25_Iron_Chef&quot;&gt;robot with no sense of taste or smell&lt;/a&gt;.&lt;/p&gt;
</description>
		<content:encoded><![CDATA[<blockquote>
  <p>“0&#215;2022”‽ Only a philistine would write U+2022 that way.</p>
</blockquote>

<p>I&#8217;m going to claim typo, or possibly a thinko, on that. As demonstrated <a href="/archives/2007/3/9/c-1-unicode-0">previously</a>, I am aware of the correct notation for code points.</p>

<p>On C portability: it has to be said that in comparison to many other languages, C has a relatively poor standard library, so you often find yourself needing to use third-party libraries or specific system calls. Either way portability takes a hit. The same is true of all languages, but it is far more common in C.</p>

<p>So the claim about C being the most portable of languages should perhaps be clarified thus: If you have a program written entirely in C using only the standard library, you&#8217;ll be able to port it to a wider range of systems than for an equivalent program in any other language.</p>

<p>I agree with all of your other points, although the line I drew for myself was more about practical experience than essential theoretical knowledge. And that&#8217;s a somewhat blurry line obviously.</p>

<p>I didn&#8217;t mean to claim that it was acceptable to know only one language, just that C should be one of them.</p>

<p>Jeff Atwood disclosed recently that he had <a href="http://blog.stackoverflow.com/index.php/2008/04/podcast-2/">never learned C</a>. To me, this revelation is a profound hit to his credibility (and see a forthcoming blog article on that). It is like finding out that the chef who cooked your meal is a <a href="http://en.wikipedia.org/wiki/The_30%25_Iron_Chef">robot with no sense of taste or smell</a>.</p>]]></content:encoded>
	</item>
	<item>
		<title>By: Aristotle Pagaltzis</title>
		<link>http://girtby.net/archives/2008/05/11/developer-essentials/comment-page-1/#comment-1693</link>
		<dc:creator>Aristotle Pagaltzis</dc:creator>
		<pubDate>Sun, 11 May 2008 13:09:00 +0000</pubDate>
		<guid isPermaLink="false">http://girtby.net/2008/05/15/developer-essentials#comment-1693</guid>
		<description>&lt;blockquote&gt;
  &lt;p&gt;If you have a program written entirely in C using only the standard library, you’ll be able to port it to a wider range of systems than for an equivalent program in any other language.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Actually, that isn’t even entirely correct for the standard library; eg. for file I/O you probably need to respect the system’s path name conventions, and there are very, &lt;em&gt;very&lt;/em&gt; weird platforms out there. If Unix is your reference point, f.ex., VMS is 5× as weird as Win32. And then there are the embedded devices that don’t even have anything resembling traditional file systems; how do you even make your I/O calls compile on that?&lt;/p&gt;

&lt;p&gt;So the set of truly portable C programs is surprisingly small and surprisingly uninteresting. If you couple C with a library like GLib, you actually reach a lot more systems despite – because GLib itself isn’t available everywhere that C is – nominally losing a bunch of platforms.&lt;/p&gt;

&lt;p&gt;So… it’s a very complex picture. You can probably summarise it like this: &lt;i&gt;C is extremely portable, it’s just that C programs are a lot less so…&lt;/i&gt;&lt;/p&gt;
</description>
		<content:encoded><![CDATA[<blockquote>
  <p>If you have a program written entirely in C using only the standard library, you’ll be able to port it to a wider range of systems than for an equivalent program in any other language.</p>
</blockquote>

<p>Actually, that isn’t even entirely correct for the standard library; eg. for file I/O you probably need to respect the system’s path name conventions, and there are very, <em>very</em> weird platforms out there. If Unix is your reference point, f.ex., VMS is 5× as weird as Win32. And then there are the embedded devices that don’t even have anything resembling traditional file systems; how do you even make your I/O calls compile on that?</p>

<p>So the set of truly portable C programs is surprisingly small and surprisingly uninteresting. If you couple C with a library like GLib, you actually reach a lot more systems despite – because GLib itself isn’t available everywhere that C is – nominally losing a bunch of platforms.</p>

<p>So… it’s a very complex picture. You can probably summarise it like this: <i>C is extremely portable, it’s just that C programs are a lot less so…</i></p>]]></content:encoded>
	</item>
	<item>
		<title>By: Chris</title>
		<link>http://girtby.net/archives/2008/05/11/developer-essentials/comment-page-1/#comment-1694</link>
		<dc:creator>Chris</dc:creator>
		<pubDate>Sun, 11 May 2008 13:09:00 +0000</pubDate>
		<guid isPermaLink="false">http://girtby.net/2008/05/15/developer-essentials#comment-1694</guid>
		<description>&lt;p&gt;Good stuff.&lt;/p&gt;

&lt;p&gt;I wanted to support elaborate on Aristotle&#039;s (and Joel&#039;s) point:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;I would also argue that a working knowledge of assembler is equally as important.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Learning assembler (and more than one instruction set architecture) certainly provides a far better understanding of machine architecture than C. I think that if you learn an assembler, don&#039;t stop at learning about how RAM and CPU work together. The underlying goal is to understand machine architecture. A few of the hardware components and low level interactions that can affect even the highest-level software.  I&#039;d strive to understand interrupts; DMA; clocks and counters; interactive, network and block IO; and typical bus peripheral interaction in general.&lt;/p&gt;

&lt;p&gt;I&#039;d lump debuggers into the sniffer class and head off on a tangent about how &quot;sniffers&quot; and debuggers often rely on knowledge of the, possibly non-obvious, underlying implementation.  e.g. you need to learn assembler to debug stack overruns in C/C++ and you often need to understand TCP, IP, routing and associated protocols to understand why you&#039;re not even getting a 404 error from your beautifully abstracted SOA stack.&lt;/p&gt;

&lt;p&gt;OO, I would argue is a must-have, even if you choose to &lt;em&gt;ignore&lt;/em&gt; it.  Sure it&#039;s not essential for writing good code, and over-exuberant application is a pain in the ass, but it&#039;s a set of organising principles that&#039;s easier to learn through OO than to develop yourself from first principles.&lt;/p&gt;

&lt;p&gt;Other stuff I&#039;d add which I think is essential, but I understand your need to not go all Unabomber on our asses:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The ability to write stuff down &lt;em&gt;and&lt;/em&gt; explain it to another human being with sufficient lucidity that you don&#039;t end up maintaining every piece of code you touch forever or driving your co-workers to feign death to avoid being assigned to your projects (just had to get that off my chest)&lt;/li&gt;
&lt;li&gt;Concurrency&lt;/li&gt;
&lt;li&gt;Unit testing (which you mention)&lt;/li&gt;
&lt;li&gt;Crypto basics&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;But I like your list.  It reminds me that I need to find a cure for my fear of Unicode.&lt;/p&gt;
</description>
		<content:encoded><![CDATA[<p>Good stuff.</p>

<p>I wanted to support elaborate on Aristotle&#8217;s (and Joel&#8217;s) point:</p>

<blockquote>
  <p>I would also argue that a working knowledge of assembler is equally as important.</p>
</blockquote>

<p>Learning assembler (and more than one instruction set architecture) certainly provides a far better understanding of machine architecture than C. I think that if you learn an assembler, don&#8217;t stop at learning about how RAM and CPU work together. The underlying goal is to understand machine architecture. A few of the hardware components and low level interactions that can affect even the highest-level software.  I&#8217;d strive to understand interrupts; DMA; clocks and counters; interactive, network and block IO; and typical bus peripheral interaction in general.</p>

<p>I&#8217;d lump debuggers into the sniffer class and head off on a tangent about how &#8220;sniffers&#8221; and debuggers often rely on knowledge of the, possibly non-obvious, underlying implementation.  e.g. you need to learn assembler to debug stack overruns in C/C++ and you often need to understand TCP, IP, routing and associated protocols to understand why you&#8217;re not even getting a 404 error from your beautifully abstracted SOA stack.</p>

<p>OO, I would argue is a must-have, even if you choose to <em>ignore</em> it.  Sure it&#8217;s not essential for writing good code, and over-exuberant application is a pain in the ass, but it&#8217;s a set of organising principles that&#8217;s easier to learn through OO than to develop yourself from first principles.</p>

<p>Other stuff I&#8217;d add which I think is essential, but I understand your need to not go all Unabomber on our asses:</p>

<ul>
<li>The ability to write stuff down <em>and</em> explain it to another human being with sufficient lucidity that you don&#8217;t end up maintaining every piece of code you touch forever or driving your co-workers to feign death to avoid being assigned to your projects (just had to get that off my chest)</li>
<li>Concurrency</li>
<li>Unit testing (which you mention)</li>
<li>Crypto basics</li>
</ul>

<p>But I like your list.  It reminds me that I need to find a cure for my fear of Unicode.</p>]]></content:encoded>
	</item>
	<item>
		<title>By: Gomp</title>
		<link>http://girtby.net/archives/2008/05/11/developer-essentials/comment-page-1/#comment-1695</link>
		<dc:creator>Gomp</dc:creator>
		<pubDate>Sun, 11 May 2008 13:09:00 +0000</pubDate>
		<guid isPermaLink="false">http://girtby.net/2008/05/15/developer-essentials#comment-1695</guid>
		<description>&lt;p&gt;Learning to build other&#039;s code, run it, trace it, read it, and understand it is an important skill I think. At least, for open-source stuff, and learning.&lt;/p&gt;
</description>
		<content:encoded><![CDATA[<p>Learning to build other&#8217;s code, run it, trace it, read it, and understand it is an important skill I think. At least, for open-source stuff, and learning.</p>]]></content:encoded>
	</item>
	<item>
		<title>By: Doug</title>
		<link>http://girtby.net/archives/2008/05/11/developer-essentials/comment-page-1/#comment-1696</link>
		<dc:creator>Doug</dc:creator>
		<pubDate>Sun, 11 May 2008 13:09:00 +0000</pubDate>
		<guid isPermaLink="false">http://girtby.net/2008/05/15/developer-essentials#comment-1696</guid>
		<description>&lt;p&gt;This is a very good list.  To some degree that&#039;s probably because it lines up well with my skill set.   :-)&lt;/p&gt;

&lt;p&gt;I found this list after seeing someone criticize it at Atwood&#039;s blog; clearly there is a cultural divide between many developers who have had to deal with re-engineering legacy systems and those who never learned C or makefiles (not that that makes them bad people or programmers).&lt;/p&gt;

&lt;p&gt;One thing I can say is that I am glad I learned the old school tools.  Today I have enormous advantages when someone&#039;s stuck due to some strange link error, or a memory overrun appears in some code that hasn&#039;t been touched in 6 (or 16) years, or two applications aren&#039;t talking, and aren&#039;t logging, because I&#039;ve got the background to deal with it.  Knowing makefiles, C, and sniffers certainly comes in handy, and EVERY shop needs at least one person who can engage with the machine on that level.&lt;/p&gt;

&lt;p&gt;Also, every development team needs at least one person who understands basic system administration (including package management and tool administration i.e. Subversion).  I find that having a good development/admin on a project can save man-months of effort due to the fact that you can simply tell them, &quot;I have problem X&quot; and they immediately respond with &quot;Oh, I know a tool for that--give me a day and I&#039;ll have it set up.&quot;&lt;/p&gt;

&lt;p&gt;The folks who work entirely within an IDE and an interpreted language may be fine coders and developers, but there is more to the discipline of engineering than knowing C#/Java and design patterns.&lt;/p&gt;

&lt;p&gt;Kudos.&lt;/p&gt;
</description>
		<content:encoded><![CDATA[<p>This is a very good list.  To some degree that&#8217;s probably because it lines up well with my skill set.   <img src='http://girtby.net/wp-includes/images/smilies/icon_smile.gif' alt=':-)' class='wp-smiley' /> </p>

<p>I found this list after seeing someone criticize it at Atwood&#8217;s blog; clearly there is a cultural divide between many developers who have had to deal with re-engineering legacy systems and those who never learned C or makefiles (not that that makes them bad people or programmers).</p>

<p>One thing I can say is that I am glad I learned the old school tools.  Today I have enormous advantages when someone&#8217;s stuck due to some strange link error, or a memory overrun appears in some code that hasn&#8217;t been touched in 6 (or 16) years, or two applications aren&#8217;t talking, and aren&#8217;t logging, because I&#8217;ve got the background to deal with it.  Knowing makefiles, C, and sniffers certainly comes in handy, and EVERY shop needs at least one person who can engage with the machine on that level.</p>

<p>Also, every development team needs at least one person who understands basic system administration (including package management and tool administration i.e. Subversion).  I find that having a good development/admin on a project can save man-months of effort due to the fact that you can simply tell them, &#8220;I have problem X&#8221; and they immediately respond with &#8220;Oh, I know a tool for that&#8211;give me a day and I&#8217;ll have it set up.&#8221;</p>

<p>The folks who work entirely within an IDE and an interpreted language may be fine coders and developers, but there is more to the discipline of engineering than knowing C#/Java and design patterns.</p>

<p>Kudos.</p>]]></content:encoded>
	</item>
	<item>
		<title>By: Michael Rhodes</title>
		<link>http://girtby.net/archives/2008/05/11/developer-essentials/comment-page-1/#comment-1697</link>
		<dc:creator>Michael Rhodes</dc:creator>
		<pubDate>Sun, 11 May 2008 13:09:00 +0000</pubDate>
		<guid isPermaLink="false">http://girtby.net/2008/05/15/developer-essentials#comment-1697</guid>
		<description>&lt;p&gt;With respect to C portability, I read Alastair&#039;s point as &quot;the skill of programming C is one of the most portable&quot; as opposed to &quot;a given C program is portable&quot;. In the former reading, the point isn&#039;t nearly so debatable!&lt;/p&gt;

&lt;p&gt;I second the call for a much wider knowledge of basic crypto. The maxim &quot;never invent your own crypto&quot; seems to be ignored by too many developers. With an ever ever wider range of personal data being stored on internet-facing systems, basic knowledge of securing data effectively is an essential.&lt;/p&gt;
</description>
		<content:encoded><![CDATA[<p>With respect to C portability, I read Alastair&#8217;s point as &#8220;the skill of programming C is one of the most portable&#8221; as opposed to &#8220;a given C program is portable&#8221;. In the former reading, the point isn&#8217;t nearly so debatable!</p>

<p>I second the call for a much wider knowledge of basic crypto. The maxim &#8220;never invent your own crypto&#8221; seems to be ignored by too many developers. With an ever ever wider range of personal data being stored on internet-facing systems, basic knowledge of securing data effectively is an essential.</p>]]></content:encoded>
	</item>
</channel>
</rss>
