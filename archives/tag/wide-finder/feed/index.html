<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>girtby.net &#187; wide finder</title>
	<atom:link href="http://girtby.net/archives/tag/wide-finder/feed/" rel="self" type="application/rss+xml" />
	<link>http://girtby.net</link>
	<description>this blog is girtby.net</description>
	<lastBuildDate>Thu, 17 Sep 2009 14:27:44 +0000</lastBuildDate>
	<generator>http://wordpress.org/?v=2.9-rare</generator>
	<language>en</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
			<item>
		<title>Wide Finder 2: The Widening</title>
		<link>http://girtby.net/archives/2008/07/03/wide-finder-2-the-widening/</link>
		<comments>http://girtby.net/archives/2008/07/03/wide-finder-2-the-widening/#comments</comments>
		<pubDate>Thu, 03 Jul 2008 03:27:00 +0000</pubDate>
		<dc:creator>alastair</dc:creator>
				<category><![CDATA[Nerd Factor X]]></category>
		<category><![CDATA[c++]]></category>
		<category><![CDATA[performance]]></category>
		<category><![CDATA[wide finder]]></category>

		<guid isPermaLink="false">http://girtby.net/2008/07/08/wide-finder-2-the-widening</guid>
		<description><![CDATA[&#60;movie-trailer-guy&#62; Many months ago he attempted Tim Bray&#8217;s first Wide Finder in C++, mainly as a coding exercise. Back then the goal was readability and conciseness. This time &#8230; it&#8217;s performanceal. &#60;/movie-trailer-guy&#62;



Targeting the Hardware of the Future

Computer architecture evolution is currently in the process of changing direction. Instead of CPUs becoming progressively ever faster, they [...]]]></description>
			<content:encoded><![CDATA[<p><code>&lt;movie-trailer-guy&gt;</code> Many months ago he attempted Tim Bray&#8217;s first <a href="/archives/2007/10/9/wide-finder-in-c">Wide Finder in C++</a>, mainly as a coding exercise. Back then the goal was readability and conciseness. This time &#8230; it&#8217;s performanceal. <code>&lt;/movie-trailer-guy&gt;</code></p>

<p><span id="more-3049"></span></p>

<h4>Targeting the Hardware of the Future</h4>

<p>Computer architecture evolution is currently in the process of changing direction. Instead of CPUs becoming progressively ever faster, they are going &#8220;wider&#8221;. This means more processing cores, each of which is relatively low-powered. The combined processing power of multiple cores is greater than is achievable with traditional single core architectures, but requires new programming techniques. These techniques are perhaps well-understood at a theory level, but the Wide Finder project is an attempt to put theory into practice with real-world tasks by everyday coders, such as myself.</p>

<p>The goal of a <a href="http://wikis.sun.com/display/WideFinder/Wide+Finder+Home">Wide Finder 2</a> implementation is to produce some simple statistics from a very large (42GB) data file. The target machine is a Sun Fire T2000 with 8 cores (32 threads) and 32 GB of RAM. The task is relatively simple: we have to read the file, which contains web server log entries, and produce some elementary statistics such as the top 10 pages by hit, the top 10 clients, and so forth. Obviously it&#8217;s I/O bound &#8230; or is it?</p>

<p>I attempted this in (hopefully) idiomatic C++, using the <a href="http://www.boost.org/">Boost</a> libraries. For those unfamiliar with Boost, you can think of it as the non-standard library, or maybe the unofficial standard libary. Basically if you&#8217;re not using Boost libraries today, you soon will be, because many of the them have gone on to form the basis for the TR1 standard library extensions, and hence targeted for inclusion in the next official C++ standard, known as C++0x. Thanks to Boost, my code is completely portable, compiling on both gcc (on my Mac) and Sun Studio compiler (on the T2000) without even a single <code>#ifdef</code>.</p>

<h4>The Results, So Far</h4>

<p>So, C++ should be able to whip all those other languages like Java into submission you might think, right? Well, I think the <a href="http://wikis.sun.com/display/WideFinder/Results">results</a> speak for themselves. My time of 16 minutes is prettymuch in the middle of the pack. Not bad, but not outstanding either, and still behind some of the Java (or JVM-based) implementations. I have a few more optimisations up my sleeve though, so we&#8217;ll see how they pan out.</p>

<p>However the clear winner in my view, and hence worthy of much more recognition than it currently enjoys, is <a href="http://caml.inria.fr/ocaml/">OCaml</a>. With a run time of 5 minutes this is perilously <a href="http://groups.google.com/group/wide-finder/browse_thread/thread/06cf51fbbd4774e0">close to the raw I/O speed</a> sustainable on this box. Not only that but it was all done with ~150 lines of code which is frankly amazing (especially compared to my ~500 line C++ implementation). So OCaml is definitely a language to look at, in my humble opinion.</p>

<p>Hit the links from that results page for some often fascinating insights from the other Wide Finder implementers.</p>

<h4>How To Go Wide</h4>

<p>Fundamentally I think my approach is fairly similar to many of the other Wide Finders. This was to divide the input file into chunks, then walk through each using multiple threads. Each thread accumulates statistics in the form of hash tables. The individual hash tables are then merged before finally being sorted to produce the top-10 reports.</p>

<p>I want to share in detail some of the techniques that I used but like I said I&#8217;m still refining them. For now let me just point to a couple of key techniques that got me into contention for this project:</p>

<ul>
<li><p>When it comes to this much data, you can&#8217;t afford to copy anything. This means I/O using <code>mmap</code>, and doing as much processing &#8220;in-place&#8221; as possible. For C++ this also means throwing out the <code>iostreams</code> library (even though it is otherwise quite well suited to this type of task, as demonstrated previously). And even with a 64-bit binary, you really don&#8217;t want to mmap an entire 42GB data file into memory, trust me [<strong>Update:</strong> Or maybe not. See <a href="#comment-3058">comment</a> below]. So I ended up with some quite ugly code to deal with mmap-ing segments of the input file while respecting chunk (ie line) boundaries and page alignment boundaries.</p></li>
<li><p>Multi-threaded C++ applications are always at risk of experiencing contention, but this is especially so when it comes to memory allocation. Doing too much allocation can kill any parallel processing you do with C++, because <code>malloc</code> and <code>free</code> both grab global mutexes (or worse, spinlocks) prior to doing their stuff. To solve this problem I ended up using a custom thread-specific memory allocator based on the Boost.Pool library. This minimises the number of times that the thread grabs memory during the normal course of operation. Code forthcoming.</p></li>
</ul>

<p>Mad props to Shark, which is part of the Mac OS X developer suite. It pinpointed my bottlenecks  very quickly and simply. An indispensable tool, don&#8217;t jump over <em>this</em> Shark.</p>

<h4>Future Work</h4>

<p>So I&#8217;ve got some more ideas on how to go even wider, and I&#8217;ll update here with the results. Basically it&#8217;s applying the above two techniques more thoroughly; minimise copying of data, and minimise memory allocation. (In particular the Boost.Regex library is next on my list to convert to using a thread-specific memory pool). Will let you know how it goes.</p>
]]></content:encoded>
			<wfw:commentRss>http://girtby.net/archives/2008/07/03/wide-finder-2-the-widening/feed/</wfw:commentRss>
		<slash:comments>7</slash:comments>
		</item>
		<item>
		<title>Wide Finder in C++</title>
		<link>http://girtby.net/archives/2007/10/09/wide-finder-in-c/</link>
		<comments>http://girtby.net/archives/2007/10/09/wide-finder-in-c/#comments</comments>
		<pubDate>Tue, 09 Oct 2007 11:07:00 +0000</pubDate>
		<dc:creator>alastair</dc:creator>
				<category><![CDATA[Nerd Factor X]]></category>
		<category><![CDATA[benchmark]]></category>
		<category><![CDATA[boost]]></category>
		<category><![CDATA[c++]]></category>
		<category><![CDATA[wide finder]]></category>

		<guid isPermaLink="false">http://girtby.net/2007/11/09/wide-finder-in-c</guid>
		<description><![CDATA[Have you been following Tim Bray&#8217;s Wide Finder project? It&#8217;s an exercise to express a fairly simple task in a manner that will scale across multiple CPU cores. Some of Tim&#8217;s initial progress with Erlang, and other contributors in different languages, is quite fascinating.

Like Tim I was also amused at Pete Kirkham&#8217;s C++ implementation  [...]]]></description>
			<content:encoded><![CDATA[<p>Have you been following Tim Bray&#8217;s <a href="http://www.tbray.org/ongoing/When/200x/2007/09/20/Wide-Finder">Wide Finder project</a>? It&#8217;s an exercise to express a fairly simple task in a manner that will scale across multiple CPU cores. Some of Tim&#8217;s initial progress with Erlang, and other contributors in different languages, is quite fascinating.</p>

<p><a href="http://www.tbray.org/ongoing/When/200x/2007/10/01/WF-Roundup">Like Tim</a> I was also amused at <a href="http://www.tincancamera.com/blog/2007/09/wide-finder-parallelism-and-languages.html">Pete Kirkham&#8217;s C++ implementation </a> which was purported to be shorter than an initial attempt by an Erlang expert (in Erlang obviously). However on closer examination it seems that Pete&#8217;s C++ implementation was simply handling the I/O portion with simplified parsing and not the subsequent sorting.</p>

<p>So as <a href="/archives/2007/2/26/kata-four-in-c">another</a> C++ coding Kata I decided to have a go. Whereas Tim&#8217;s goal was to evaluate different methods of expressing algoritms for parallel computation, mine was a lot more modest: just get it running concisely in C++ and compare performance with the raw Ruby version. Here&#8217;s what I came up with.</p>

<p><span id="more-2047"></span></p>

<pre class="htmlize">
<span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;boost/iostreams/device/mapped_file.hpp&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;boost/regex.hpp&gt;</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="constant">std</span>;

<span class="keyword">const</span> <span class="constant">boost</span>::<span class="type">regex</span> <span class="function-name">get_re</span>(<span class="string">"GET /ongoing/When/\\d{3}x/(\\d{4}/\\d{2}/\\d{2}/[^ .]+) "</span>);

<span class="keyword">typedef</span> <span class="type">map</span>&lt;<span class="type">string</span>, <span class="type">unsigned</span>&gt; <span class="type">counts_by_key_t</span>;
<span class="keyword">typedef</span> <span class="type">multimap</span>&lt;<span class="type">unsigned</span>, <span class="type">string</span>&gt; <span class="type">keys_by_count_t</span>;

<span class="type">int</span> <span class="function-name">main</span>(<span class="type">int</span> <span class="variable-name">argc</span>, <span class="type">char</span> *<span class="variable-name">argv</span>[])
{
  <span class="type">counts_by_key_t</span> <span class="variable-name">counts_by_key</span>;
  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable-name">arg</span> = 1; arg &lt; argc; ++arg) {
    <span class="keyword">try</span> {
      <span class="constant">boost</span>::<span class="constant">iostreams</span>::<span class="type">mapped_file_source</span> <span class="variable-name">mf</span>(<span class="type">argv</span>[arg]);

      <span class="constant">boost</span>::<span class="type">cregex_iterator</span> <span class="variable-name">regi</span>(mf.begin(), mf.end(), get_re), <span class="variable-name">rege</span>;
      <span class="keyword">for</span>(; regi != rege; ++regi) {
        counts_by_key[(*regi)[1].str()] += 1;
      }
    } <span class="keyword">catch</span> (<span class="constant">ios</span>::<span class="type">failure</span> <span class="variable-name">e</span>) {
      cerr &lt;&lt; argv[arg] &lt;&lt; <span class="string">": "</span> &lt;&lt; e.what() &lt;&lt; endl;
      <span class="keyword">return</span> 1;
    }
  }

  <span class="type">keys_by_count_t</span> <span class="variable-name">keys_by_count</span>;
  <span class="keyword">for</span>(<span class="constant">counts_by_key_t</span>::<span class="type">const_iterator</span> <span class="variable-name">i</span> = counts_by_key.begin();
      i != counts_by_key.end(); ++i) {
    keys_by_count.insert(make_pair(i-&gt;second, i-&gt;first));
  }

  <span class="type">unsigned</span> <span class="variable-name">n</span> = 10;
  <span class="keyword">for</span>(<span class="constant">keys_by_count_t</span>::<span class="type">reverse_iterator</span> <span class="variable-name">ri</span> = keys_by_count.rbegin();
      n &amp;&amp; ri != keys_by_count.rend(); ++ri, --n) {

    cout &lt;&lt; ri-&gt;first &lt;&lt; <span class="string">": "</span> &lt;&lt; ri-&gt;second &lt;&lt; endl;
  }
  <span class="keyword">return</span> 0;
}
</pre>

<p>So at 42 lines this one really <em>is</em> shorter than the 84-line Erlang version. Not a million miles away from the Ruby version either, in length if not in readability. However, I&#8217;ve made some simplifications, or taken some liberties, depending on your point of view:</p>

<ul>
<li><p>Firstly, Boost is a third-party library and hence this is not standard C++. Given the (general) difficulty of incorporating libraries into C++ apps this might be more of a problem than on other languages where CPAN/RubyForge/CheeseShop/whatever rules supreme. However I would argue that Boost is such an indispensable part of modern C++ development that relying on it is quite acceptable, even for tasks like this.</p></li>
<li><p>Also, I&#8217;m using Boost&#8217;s <code>mapped_file_stream</code>, which uses a memory map to iterate through the file. This is very useful and quick but obviously places limits on the size of the file. Fortunately it handles oversize files gracefully.</p></li>
<li><p>That <code>reverse_iterator</code> should be a <code>const_reverse_iterator</code>, but I had to work around a <a href="http://gcc.gnu.org/bugzilla/show_bug.cgi?id=11729">gcc bug</a>.</p></li>
<li><p>C++ generic programming purists may be scoffing at my explicit iteration through the containers. Try as I might I could not formulate a way of using the standard algorithms without signficantly increasing the complexity of the code. Inverting the <code>counts_by_key</code> map to create the <code>keys_by_count</code> multimap sounds particularly like the sort of thing that should be possible using the standard algorithms, but I was unable to work it out.</p></li>
</ul>

<p>Removing the explicit iteration may prove to be a useful exercise, in order to get better parallelization. I can picture a class of STL algorithms which are smart enough to automatically distribute work amongst different worker threads, coordinate their shared state, etc. A <code>parallel_for_each</code> algorithm perhaps. Fully utilising existing algorithms such as <code>for_each</code> seems like a necessary first step towards this goal.</p>

<p>My other goal with this was to look at performance. The C++ version above processes the 200MB file in about <strong>4.5 seconds</strong> on my laptop (running WinXP, code compiled with MSVC++ 8.0).</p>

<p>By comparison the Ruby version runs in <strong>5.0 seconds</strong>. This is pretty damn impressive if you ask me, given that it&#8217;s <em>not</em> using memory-mapped IO.</p>

<p>For an encore I would like to convert the code above to use regular file I/O. An initial attempt to use the <code>file_iterator</code> class (from the Spirit library, also part of Boost) was not hopeful; boosting the runtime up to 30 seconds. I also looked at using the standard C++ iostream iterators but the regex matching needs bidirectional iterators, and they aren&#8217;t.</p>

<p>Oh, and don&#8217;t blame me that the code isn&#8217;t <a href="/archives/2007/3/9/c-1-unicode-0">unicode safe</a>. That was part of the brief!</p>
]]></content:encoded>
			<wfw:commentRss>http://girtby.net/archives/2007/10/09/wide-finder-in-c/feed/</wfw:commentRss>
		<slash:comments>4</slash:comments>
		</item>
	</channel>
</rss>
