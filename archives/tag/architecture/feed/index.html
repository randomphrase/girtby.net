<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>girtby.net &#187; architecture</title>
	<atom:link href="http://girtby.net/archives/tag/architecture/feed/" rel="self" type="application/rss+xml" />
	<link>http://girtby.net</link>
	<description>this blog is girtby.net</description>
	<lastBuildDate>Thu, 17 Sep 2009 14:27:44 +0000</lastBuildDate>
	<generator>http://wordpress.org/?v=2.9-rare</generator>
	<language>en</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
			<item>
		<title>Twitter over IP</title>
		<link>http://girtby.net/archives/2008/06/04/twitter-over-ip/</link>
		<comments>http://girtby.net/archives/2008/06/04/twitter-over-ip/#comments</comments>
		<pubDate>Wed, 04 Jun 2008 10:43:00 +0000</pubDate>
		<dc:creator>alastair</dc:creator>
				<category><![CDATA[Linkpimpin']]></category>
		<category><![CDATA[Nerd Factor X]]></category>
		<category><![CDATA[architecture]]></category>
		<category><![CDATA[end-to-end]]></category>
		<category><![CDATA[network]]></category>
		<category><![CDATA[twitter]]></category>

		<guid isPermaLink="false">http://girtby.net/2008/06/04/twitter-over-ip</guid>
		<description><![CDATA[Let&#8217;s solve Twitter&#8217;s scalability problems, shall we?

So, like most people, I don&#8217;t know much about the problems there and certainly don&#8217;t have any solutions to suggest. But I do know there are a certain class of solutions which aren&#8217;t on the table.

If you look at Twitter from a suitably high vantage point you see real-time [...]]]></description>
			<content:encoded><![CDATA[<p>Let&#8217;s solve Twitter&#8217;s scalability problems, shall we?</p>

<p>So, like most people, I don&#8217;t know much about the problems there and certainly don&#8217;t have any solutions to suggest. But I do know there are a certain class of solutions which <em>aren&#8217;t</em> on the table.</p>

<p>If you look at Twitter from a suitably high vantage point you see real-time communication between small groups. People entering short messages and having these messages appear at their peers a small time later. There&#8217;s also a central archive, but I&#8217;ve heard Twitter described as &#8220;public Instant-Messaging&#8221; and this seems to characterise it best for me.</p>

<p>In short, Twitter seems more suited to peer-to-peer communication than to client-server. What sort of protocol would it use? I can imagine a protocol which would be probably UDP-based, and which would send tweets to followers either directly from peers or perhaps through a local aggregation point. Large groups of followers could perhaps even use UDP multicast. Archive servers could be reached through network anycast addresses, to allow for greater decentralisation. IPv6 to get universal connectivity. And so on; fill in your own pet network technology here, there are certainly lots of potential solutions.</p>

<p>Instead of these, clients communicate directly with the Twitter servers using HTTP. Not only that, but they <em>poll</em> for updates. Bit of an architectural blunder, you might think. Well not really. In fact I don&#8217;t think the Twitter designers had any choice.</p>

<p>Once upon a time it was possible to deploy new application-layer protocols on the Internet. But those times have passed, it seems. These days, it&#8217;s HTTP(S) or nothing. And this is <em>not</em> the protocol you would choose for carrying tweets, if you had the choice. So the fact that twitter works <em>at all</em> over this sub-optimal application-layer protocol is quite an achievement.</p>

<p>This is a great example of the many ways in which <a href="/archives/2006/01/04/making-connections/">innovation can be stifled</a> by enforcing a lowest-common-denominator.</p>

<p>The impact is of course more widespread than just Twitter. In fact, the so-called end-to-end principle which was one of the fundamental founding principles of the Internet is now all but abandoned in practice. Geoff Huston examines the issue in some detail in a <a href="http://www.potaroo.net/ispcol/2008-05/eoe2e.html">recent article</a>, and it is highly recommended.</p>

<p>Of course, there are no easy answers, either for Twitter or the next application to suffer due to the proliferation of network middleware. But it&#8217;s certainly an issue that does need to be more prominent.</p>

<p>(This post is an obvious departure from my usual style of blatant attack pieces in order to score traffic and fame for myself. Normal service will resume shortly.)</p>
]]></content:encoded>
			<wfw:commentRss>http://girtby.net/archives/2008/06/04/twitter-over-ip/feed/</wfw:commentRss>
		<slash:comments>8</slash:comments>
		</item>
		<item>
		<title>Required Viewing</title>
		<link>http://girtby.net/archives/2007/11/06/required-viewing/</link>
		<comments>http://girtby.net/archives/2007/11/06/required-viewing/#comments</comments>
		<pubDate>Tue, 06 Nov 2007 22:39:00 +0000</pubDate>
		<dc:creator>alastair</dc:creator>
				<category><![CDATA[Linkpimpin']]></category>
		<category><![CDATA[Nerd Factor X]]></category>
		<category><![CDATA[architecture]]></category>
		<category><![CDATA[c++]]></category>
		<category><![CDATA[development]]></category>
		<category><![CDATA[memory]]></category>
		<category><![CDATA[performance]]></category>

		<guid isPermaLink="false">http://girtby.net/2007/11/13/required-viewing</guid>
		<description><![CDATA[If you&#8217;re at all interested in computing technology you can&#8217;t help but be amazed at the advances in CPU power over the last few decades, Moore&#8217;s Law, blah blah blah. But a few seconds pondering this invariably provokes the question as to how long this party can last.

The commonly accepted wisdom is that CPUs have [...]]]></description>
			<content:encoded><![CDATA[<p>If you&#8217;re at all interested in computing technology you can&#8217;t help but be amazed at the advances in CPU power over the last few decades, Moore&#8217;s Law, blah blah blah. But a few seconds pondering this invariably provokes the question as to how long this party can last.</p>

<p>The commonly accepted wisdom is that CPUs have gotten about as fast as they are likely to go in terms of sheer clock speed, and now manufacturers are turning to multiprocessing to provide more processing power for a given price point. The recent Intel price drops which made the quad-core Q6600 CPU available for less than AUD400 are a highly relevent (and welcome) data point to illustrate this trend.</p>

<p>This raises lots of hairy questions for developers, such as &#8220;how are we going to design our software to run efficiently in a multi-processing environment?&#8221; The previously-linked <a href="http://www.tbray.org/ongoing/When/200x/2007/09/20/Wide-Finder">wide finder</a> experiment is an attempt to explore some of these issues. And it&#8217;s pretty obvious that so far there is no silver bullet.</p>

<p>But wait, it gets worse. I will point you to a long but highly thought-provoking presentation from Herb Sutter. Turns out we are <em>already</em> hitting major architectural hurdles in the form of memory access limitations, and we&#8217;ll need to find some solutions for these <em>before</em> tackling the parallel computation problem.</p>

<p>Sutter&#8217;s presentation is deeply technical, but still quite accessible, and delivered with an engaging style that makes it <a href="http://herbsutter.spaces.live.com/blog/cns!2D4327CC297151BB!304.entry">required viewing</a>. Highly recommended.</p>

<p>I recently had some experience diagnosing some memory-related performance problems (not quite in the same class as that discussed by Sutter, but similar) and I have to say there is a serious deficit in the development tools for these kinds of problems. Currently we need to look aggregate behaviour over multiple iterations to isolate some of these problems, and this is a difficult and error-prone approach. For example, check out Sutter&#8217;s technique to discover the memory cache line size in code. In the future it would be great if we could monitor cache misses, pipeline stalls, page faults, and other performance-impacting events <em>within the debugger</em>.</p>

<p>These issues also make me wonder about how higher-level languages are going to provide appropriate abstractions to avoid the performance problems. For example, garbage collection is a major win for programmer productivity but it does encourage memory usage patterns that are not always conducive to performance given architectural limitations in the underlying hardware. The same abstraction problems affect C/C++ of course but at least there is the option to go &#8220;bare-metal&#8221; where necessary.</p>

<p>Whatever the answers are here, it&#8217;s certain there are some interesting times ahead for developers.</p>
]]></content:encoded>
			<wfw:commentRss>http://girtby.net/archives/2007/11/06/required-viewing/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
		</item>
	</channel>
</rss>
