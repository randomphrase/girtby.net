<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>girtby.net &#187; subjective</title>
	<atom:link href="http://girtby.net/archives/tag/subjective/feed/" rel="self" type="application/rss+xml" />
	<link>http://girtby.net</link>
	<description>this blog is girtby.net</description>
	<lastBuildDate>Thu, 17 Sep 2009 14:27:44 +0000</lastBuildDate>
	<generator>http://wordpress.org/?v=2.9-rare</generator>
	<language>en</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
			<item>
		<title>Why You Should Learn C++</title>
		<link>http://girtby.net/archives/2008/09/30/why-you-should-learn-c/</link>
		<comments>http://girtby.net/archives/2008/09/30/why-you-should-learn-c/#comments</comments>
		<pubDate>Tue, 30 Sep 2008 11:29:00 +0000</pubDate>
		<dc:creator>alastair</dc:creator>
				<category><![CDATA[Nerd Factor X]]></category>
		<category><![CDATA[Verisimilitude]]></category>
		<category><![CDATA[advocacy]]></category>
		<category><![CDATA[c++]]></category>
		<category><![CDATA[career]]></category>
		<category><![CDATA[reddit fodder]]></category>
		<category><![CDATA[subjective]]></category>

		<guid isPermaLink="false">http://girtby.net/2008/09/30/why-you-should-learn-c</guid>
		<description><![CDATA[Not all software development projects can sustain a reasonable living. Anyone who has worked as a professional developer will take this truth as self-evident. It&#8217;s a sad occurance, but often developers for notionally worthy projects find themselves having to abandon their dreams and find gainful employment elsewhere. The failed startup and the abandoned open-source project [...]]]></description>
			<content:encoded><![CDATA[<p>Not all software development projects can sustain a reasonable living. Anyone who has worked as a professional developer will take this truth as self-evident. It&#8217;s a sad occurance, but often developers for notionally worthy projects find themselves having to abandon their dreams and find gainful employment elsewhere. The failed startup and the abandoned open-source project are all-too-common manifestations of this.</p>

<p>I don&#8217;t have a solution for this problem, but I mention it in order to define a set P, which is the set of all software development projects that can sustain a reasonable living. Now let&#8217;s divide P into the subsets I and B.</p>

<p><span id="more-3611"></span></p>

<h4>The 010 Types Of Projects In The World</h4>

<p>Let I be the subset of P that are Interesting projects. This is obviously a subjective criterion, but for the sake of argument I&#8217;m asking you to adopt my own definition. Interesting projects are characterised by being algorithmically complex, and performance sensitive. They possibly involve large amounts of data, or an intrinsically distributed problem domain, and almost always strongly linked to mathematics. In my time I have worked on some I-projects. Most recently: native-MPEG video splicing, network performance benchmarking, and real-time automated trading.</p>

<p>Let B be the complement of I. Again, I&#8217;ll ask you to adopt my subjective definition. Projects in the B set are typically data-centric, focusing on moving a bit of data from one place to another. There&#8217;s almost certainly a relational database in there somewhere. And probably a user interface with forms, into which mindless drones spend are to spend their days keying in meaningless data. It&#8217;s called <acronym title="Create, Retrieve, Update, Delete">CRUD</acronym> for a reason.</p>

<p>In order to make B-projects at all tolerable for the developers, they are typically sexed up with the use of inappropriate technology. Enterprisey solutions emerge, gratuitously over-engineered in the hope that developers won&#8217;t impale themselves on their own keyboards out of sheer boredom. It&#8217;s a sure sign that architectural astronautics has hit reality-escape velocity when terminology is co-opted from Interesting projects; so there is probably a web services &#8220;stack&#8221; and a message service &#8220;bus&#8221; in there somewhere. But to those who care to cast a critical eye, these projects are simply moving data from one place to another, with very little transformation or aggregation or any other algorithmically tricky task required along the way.</p>

<h4>The Developer&#8217;s Dillema</h4>

<p>So: you&#8217;re a developer. The most recent rent cheque has bounced and you&#8217;ve finally admitted to yourself that you need to shelve your world-changing open source project and go out and find a paying gig. Which type of project are you going to look for?</p>

<p>&#8220;Well, der,&#8221; you might think, having looked at the title of this article, &#8220;anything that <em>doesn&#8217;t</em> involve coding in C++! That language is a <a href="http://thread.gmane.org/gmane.comp.version-control.git/57643/focus=57918">crock of shit</a>!&#8221;</p>

<p>To which I say: not so fast there bub. I&#8217;m just going to put this out there; of the I-projects, that is projects that are interesting <em>and pay the rent</em>, a substantial proportion are written in C++. In other words, C++ is over-represented in the I-projects and under-represented in the B-projects.</p>

<p><img src="/assets/2008/09/p-set.png" alt="Attempt at explaining it all with a venn diagram" title="p-set" width="312" height="233" class="size-full wp-image-3744" /></p>

<p>All of my recent I-projects have been C++ projects. So, whatever you may think about the merits or otherwise of C++ as a language, it has <em>great jobs</em>. Hey, if nothing else, you&#8217;re not likely to have to deal with WS-*. This is a good thing.</p>

<p>This is a simplification: obviously the job involves more than just the project. You may have to deal with poor air conditioning, the <a href="/archives/2005/10/26/the-virtual-furniture-police/">Virtual Furniture Police</a>, obnoxious co-workers, or even (and I wouldn&#8217;t wish it on my worst enemy) <em>commercial radio</em>. <code>&lt;shudder/&gt;</code>. For the purposes of this article I&#8217;m going to assume these inconveniences are more-or-less evenly distributed across the P set, with no net disadvantage to C++ projects.</p>

<p>Now in case I haven&#8217;t sprinkled this post with sufficient disclaimers of subjectivity, let me make one more. This is all based on my experience of the developer job market, mostly here in Sydney. Your experience and opinions may differ, and good luck to you if they do.</p>

<h4>The Rise and Purge of C++</h4>

<p>C++ itself used to be fairly evenly distributed across the P set. There was a time when it was just the default language and, despite the compiler writers valiantly struggling to keep up with a rapidly &mdash; and imaginatively &mdash; evolving standard, it was still widely used on all types of P projects. Especially the B projects; C++ and its enterprisey friends like CORBA were the way that we sexed up our data-centric applications back in the mid-90s.</p>

<p>Then Java came along and everyone who worked on B projects got swept along with it. At the time Java seemed like a huge step forward and allowed us to soar to dizzier heights of architectural astronautics. All that CORBA, SOM, COM and other nonsense would be re-invented in Java land, this time with a vague chance that it might work. For whatever reason it seems that the I projects were less affected by the Java bombshell (or by mixed metaphors, for that matter).</p>

<p>So fast forward to the present day, and we have all sorts of dreary jobs hewing enterprisey architectures out of raw Java, or C#, or even VB.NET, whatever the hell that is. C++ is yesterday&#8217;s news. The only projects still using it are, well, projects from the I set. Or, Dog help them, some projects still lumbering on from the 90s. You probably don&#8217;t want to work on one of the latter, but you almost certainly <em>do</em> want to work on one of the former. Being able to tell the difference is obviously a pre-requisite before putting the C++-has-best-jobs idea into practice.</p>

<h4>C++ : It&#8217;s Not That Bad, Really</h4>

<p>At this point you may well be thinking &#8220;well, C++ may be common amongst interesting projects, but only a few years ago you could say the same thing about FORTRAN, and I&#8217;d rather gouge my eyes out with a novelty mousepad than have to gaze upon code written in <em>either</em> of those languages!&#8221; And I sympathise with regards to FORTRAN, but modern C++ should not warrant such a reaction.</p>

<p>In 2001 a chap called Andrei Alexandrescu published a book called <cite>Modern C++ Design</cite>. Despite the ominous inclusion of &#8220;modern&#8221; in the title (to me that word always seems to denote the anachronistic), it was really groundbreaking and is still highly recommended reading. Alexandrescu showed the potential of the so-called generic programming style, which is enabled only when you have a truly powerful (albeit sometimes arcane) template system.</p>

<p>To those who, like me, struggled to use the early incarnations of generic programming, such as exhibited in the Standard Template Library, the book was something of a revelation. Today, the Boost libraries are enabling these idiom changes and in some cases going way beyond the potential glimpsed in <cite>Modern C++ Design</cite>. The result is that small-m modern C++, as exhibited by Boost itself, is <em>nothing like</em> the C++ of yore.</p>

<p>C++ has a bit of a bad reputation (as per the Linus quote above), and it is sometimes justified, but too often online I see noses turned up at C++ in favour of cooler dynamically-typed languages like Perl, Python and Ruby. But maybe this is based on an outdated perception of the C++ language, at least as it is practiced today, because you certainly <a href="http://herbsutter.wordpress.com/2008/06/20/type-inference-vs-staticdynamic-typing/">can use dynamic typing in C++</a>, for one thing.</p>

<p>I think it&#8217;s fair to say that if you were designing a better C from scratch these days, you probably wouldn&#8217;t end up with C++. But regardless of the mistakes made in the design of C++ &mdash; and I think the <a href="http://yosefk.com/c++fqa/">C++ Frequently Questioned Answers</a> page captures most of them &mdash; I think the language has aged reasonably well. I&#8217;m certainly looking forward to C++0x, the next standard with many interesting features.</p>

<h4>Spot The Ulterior Motive</h4>

<p>To recap: there are many interesting projects in C++, and despite what you may have heard, it&#8217;s really not that unpleasant to code in.</p>

<p>So, go learn C++.</p>

<p>If you already know it, then good news! There are great jobs around. Who knows, if you email me, I may be able to help you find one.</p>
]]></content:encoded>
			<wfw:commentRss>http://girtby.net/archives/2008/09/30/why-you-should-learn-c/feed/</wfw:commentRss>
		<slash:comments>22</slash:comments>
		</item>
	</channel>
</rss>
