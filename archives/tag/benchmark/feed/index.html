<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>girtby.net &#187; benchmark</title>
	<atom:link href="http://girtby.net/archives/tag/benchmark/feed/" rel="self" type="application/rss+xml" />
	<link>http://girtby.net</link>
	<description>this blog is girtby.net</description>
	<lastBuildDate>Thu, 17 Sep 2009 14:27:44 +0000</lastBuildDate>
	<generator>http://wordpress.org/?v=2.9-rare</generator>
	<language>en</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
			<item>
		<title>Wide Finder in C++</title>
		<link>http://girtby.net/archives/2007/10/09/wide-finder-in-c/</link>
		<comments>http://girtby.net/archives/2007/10/09/wide-finder-in-c/#comments</comments>
		<pubDate>Tue, 09 Oct 2007 11:07:00 +0000</pubDate>
		<dc:creator>alastair</dc:creator>
				<category><![CDATA[Nerd Factor X]]></category>
		<category><![CDATA[benchmark]]></category>
		<category><![CDATA[boost]]></category>
		<category><![CDATA[c++]]></category>
		<category><![CDATA[wide finder]]></category>

		<guid isPermaLink="false">http://girtby.net/2007/11/09/wide-finder-in-c</guid>
		<description><![CDATA[Have you been following Tim Bray&#8217;s Wide Finder project? It&#8217;s an exercise to express a fairly simple task in a manner that will scale across multiple CPU cores. Some of Tim&#8217;s initial progress with Erlang, and other contributors in different languages, is quite fascinating.

Like Tim I was also amused at Pete Kirkham&#8217;s C++ implementation  [...]]]></description>
			<content:encoded><![CDATA[<p>Have you been following Tim Bray&#8217;s <a href="http://www.tbray.org/ongoing/When/200x/2007/09/20/Wide-Finder">Wide Finder project</a>? It&#8217;s an exercise to express a fairly simple task in a manner that will scale across multiple CPU cores. Some of Tim&#8217;s initial progress with Erlang, and other contributors in different languages, is quite fascinating.</p>

<p><a href="http://www.tbray.org/ongoing/When/200x/2007/10/01/WF-Roundup">Like Tim</a> I was also amused at <a href="http://www.tincancamera.com/blog/2007/09/wide-finder-parallelism-and-languages.html">Pete Kirkham&#8217;s C++ implementation </a> which was purported to be shorter than an initial attempt by an Erlang expert (in Erlang obviously). However on closer examination it seems that Pete&#8217;s C++ implementation was simply handling the I/O portion with simplified parsing and not the subsequent sorting.</p>

<p>So as <a href="/archives/2007/2/26/kata-four-in-c">another</a> C++ coding Kata I decided to have a go. Whereas Tim&#8217;s goal was to evaluate different methods of expressing algoritms for parallel computation, mine was a lot more modest: just get it running concisely in C++ and compare performance with the raw Ruby version. Here&#8217;s what I came up with.</p>

<p><span id="more-2047"></span></p>

<pre class="htmlize">
<span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;boost/iostreams/device/mapped_file.hpp&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;boost/regex.hpp&gt;</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="constant">std</span>;

<span class="keyword">const</span> <span class="constant">boost</span>::<span class="type">regex</span> <span class="function-name">get_re</span>(<span class="string">"GET /ongoing/When/\\d{3}x/(\\d{4}/\\d{2}/\\d{2}/[^ .]+) "</span>);

<span class="keyword">typedef</span> <span class="type">map</span>&lt;<span class="type">string</span>, <span class="type">unsigned</span>&gt; <span class="type">counts_by_key_t</span>;
<span class="keyword">typedef</span> <span class="type">multimap</span>&lt;<span class="type">unsigned</span>, <span class="type">string</span>&gt; <span class="type">keys_by_count_t</span>;

<span class="type">int</span> <span class="function-name">main</span>(<span class="type">int</span> <span class="variable-name">argc</span>, <span class="type">char</span> *<span class="variable-name">argv</span>[])
{
  <span class="type">counts_by_key_t</span> <span class="variable-name">counts_by_key</span>;
  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable-name">arg</span> = 1; arg &lt; argc; ++arg) {
    <span class="keyword">try</span> {
      <span class="constant">boost</span>::<span class="constant">iostreams</span>::<span class="type">mapped_file_source</span> <span class="variable-name">mf</span>(<span class="type">argv</span>[arg]);

      <span class="constant">boost</span>::<span class="type">cregex_iterator</span> <span class="variable-name">regi</span>(mf.begin(), mf.end(), get_re), <span class="variable-name">rege</span>;
      <span class="keyword">for</span>(; regi != rege; ++regi) {
        counts_by_key[(*regi)[1].str()] += 1;
      }
    } <span class="keyword">catch</span> (<span class="constant">ios</span>::<span class="type">failure</span> <span class="variable-name">e</span>) {
      cerr &lt;&lt; argv[arg] &lt;&lt; <span class="string">": "</span> &lt;&lt; e.what() &lt;&lt; endl;
      <span class="keyword">return</span> 1;
    }
  }

  <span class="type">keys_by_count_t</span> <span class="variable-name">keys_by_count</span>;
  <span class="keyword">for</span>(<span class="constant">counts_by_key_t</span>::<span class="type">const_iterator</span> <span class="variable-name">i</span> = counts_by_key.begin();
      i != counts_by_key.end(); ++i) {
    keys_by_count.insert(make_pair(i-&gt;second, i-&gt;first));
  }

  <span class="type">unsigned</span> <span class="variable-name">n</span> = 10;
  <span class="keyword">for</span>(<span class="constant">keys_by_count_t</span>::<span class="type">reverse_iterator</span> <span class="variable-name">ri</span> = keys_by_count.rbegin();
      n &amp;&amp; ri != keys_by_count.rend(); ++ri, --n) {

    cout &lt;&lt; ri-&gt;first &lt;&lt; <span class="string">": "</span> &lt;&lt; ri-&gt;second &lt;&lt; endl;
  }
  <span class="keyword">return</span> 0;
}
</pre>

<p>So at 42 lines this one really <em>is</em> shorter than the 84-line Erlang version. Not a million miles away from the Ruby version either, in length if not in readability. However, I&#8217;ve made some simplifications, or taken some liberties, depending on your point of view:</p>

<ul>
<li><p>Firstly, Boost is a third-party library and hence this is not standard C++. Given the (general) difficulty of incorporating libraries into C++ apps this might be more of a problem than on other languages where CPAN/RubyForge/CheeseShop/whatever rules supreme. However I would argue that Boost is such an indispensable part of modern C++ development that relying on it is quite acceptable, even for tasks like this.</p></li>
<li><p>Also, I&#8217;m using Boost&#8217;s <code>mapped_file_stream</code>, which uses a memory map to iterate through the file. This is very useful and quick but obviously places limits on the size of the file. Fortunately it handles oversize files gracefully.</p></li>
<li><p>That <code>reverse_iterator</code> should be a <code>const_reverse_iterator</code>, but I had to work around a <a href="http://gcc.gnu.org/bugzilla/show_bug.cgi?id=11729">gcc bug</a>.</p></li>
<li><p>C++ generic programming purists may be scoffing at my explicit iteration through the containers. Try as I might I could not formulate a way of using the standard algorithms without signficantly increasing the complexity of the code. Inverting the <code>counts_by_key</code> map to create the <code>keys_by_count</code> multimap sounds particularly like the sort of thing that should be possible using the standard algorithms, but I was unable to work it out.</p></li>
</ul>

<p>Removing the explicit iteration may prove to be a useful exercise, in order to get better parallelization. I can picture a class of STL algorithms which are smart enough to automatically distribute work amongst different worker threads, coordinate their shared state, etc. A <code>parallel_for_each</code> algorithm perhaps. Fully utilising existing algorithms such as <code>for_each</code> seems like a necessary first step towards this goal.</p>

<p>My other goal with this was to look at performance. The C++ version above processes the 200MB file in about <strong>4.5 seconds</strong> on my laptop (running WinXP, code compiled with MSVC++ 8.0).</p>

<p>By comparison the Ruby version runs in <strong>5.0 seconds</strong>. This is pretty damn impressive if you ask me, given that it&#8217;s <em>not</em> using memory-mapped IO.</p>

<p>For an encore I would like to convert the code above to use regular file I/O. An initial attempt to use the <code>file_iterator</code> class (from the Spirit library, also part of Boost) was not hopeful; boosting the runtime up to 30 seconds. I also looked at using the standard C++ iostream iterators but the regex matching needs bidirectional iterators, and they aren&#8217;t.</p>

<p>Oh, and don&#8217;t blame me that the code isn&#8217;t <a href="/archives/2007/3/9/c-1-unicode-0">unicode safe</a>. That was part of the brief!</p>
]]></content:encoded>
			<wfw:commentRss>http://girtby.net/archives/2007/10/09/wide-finder-in-c/feed/</wfw:commentRss>
		<slash:comments>4</slash:comments>
		</item>
	</channel>
</rss>
