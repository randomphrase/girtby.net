---
layout: post
status: publish
published: true
title: In Defence of C
author: alastair
author_login: admin
author_email: alastair@girtby.net
author_url: http://girtby.net
wordpress_id: 3375
wordpress_url: http://girtby.net/2008/08/23/in-defence-of-c
date: 2008-08-23 11:19:00.000000000 -05:00
categories:
- Nerd Factor X
tags:
- c++
- language
comments:
- id: 1821
  author: Brendan
  author_email: bjkeefe@bjkeefe.com
  author_url: http://bjkeefe.blogspot.com/
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: On the Stackoverflow podcasts, Joel's taken Jeff to task for his "I don't
    need to learn C" attitude a few times, too.  So, if you've got Joel <em>and</em>
    me agreeing with you, you can probably close the comments for this thread.
- id: 1822
  author: Rob
  author_email: rob.s.brit@gmail.com
  author_url: http://lovehateubuntu.blogspot.com
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: How do you feel about C++? I remember reading that post by Tim Bray and
    wondering if he was using C interchangeably with C++ or not.
- id: 1823
  author: Chris Brandsma
  author_email: chris.brandsma@gmail.com
  author_url: http://www.elegantcode.com
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    I would agree with your idea here.  I am not a C/C++ apologist by any means, but if you want to be professional developer you should be able, at minimum, to read and understand C and C++ (being able to write a C/C++ app from scratch is another matter all together).

    It is important to remember that ALL of our sub-systems are written in C (OS Kernels -- Windows and Linux), and most of our frameworks are written in C or C++ (PHP, Ruby, Perl, Java, .Net, we all have that in common).
- id: 1824
  author: markus
  author_email: ''
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    You are so right about it.

    And the fact that C is still so important in the year 2008 makes me sad.

    Sugarified Assembler code seems like a relic from one hundred years ago.
- id: 1825
  author: Chase
  author_email: ''
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: C is a lot of fun if you actually have to deal with the performance constraints
    that existed when it was invented. I'm picking up microcontroller programming
    for the Atmel AVRs. I'm using a reasonably high end ATMega ($5/ea) which is clocked
    at 16MHz, with 1024b RAM and 512b EEPROM (essentially, hard disk), as well as
    12kb program space. So a lot of the performance issues K&R had to deal with on
    the machines of their time, microcontroller programmers have to deal with today.
    It certainly makes much more sense than coding C for a dual core Core2 processor
    with 2GB of RAM.
- id: 1826
  author: john
  author_email: ''
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    Markus, I think you are missing the point when you say that C is a relic and that it's still important makes you sad. Yes, in theory you can be a Java programmer your whole life and not know what an operating system is, or that there are different kinds of CPUs. Hell, nowadays you can get away with not knowing the difference between RAM and swap and physical and virtual memory.

    It's like that old joke about hardware being too unstable, so why not just get rid of all hardware and just run software?

    Have you heard of "click and play"? It was a game development framework in which you could make games without knowing how to program. It's the extreme version of the same thing as this topic. You invariably lose the ability to do *everything* when you move up the abstraction chain. I wish someone would prove this mathematically so we could just drop this.

    Why do I have to know what a wheel is? I just want to learn to ride a skateboard.
- id: 1827
  author: Don
  author_email: ''
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: All you wussies complaining about learning C. I use it everyday as a hardware
    designer and driver programmer. It's an excellent language for low level activities
    and it wouldn't hurt you one iota to be able to understand the grammar. I prefer
    python for higher level things but I love swig+python+c/c++ when performance becomes
    an issue. There is a place for all these languages due to the ever increasing
    penetration of computers at all strata of the human endeavour. All the guy is
    trying to say is that it is important to know at least somethings about the platform
    underneath, because almost assuredly you will hit a limitation you won't overcome
    with your higher level abstractions.
- id: 1828
  author: Tom Ritchford
  author_email: tom@swirly.com
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    "Sugarified Assembler code"?  Methinks you really haven't written very much assembler code if you can say this, even about C.  If you meant C/C++ then you must simply be joking.

    It takes at least five times as long to say something in assembly as C.  The volume of code alone makes it hard to keep track of what's going on.  I've written medium-sized assembly projects - it takes a lot of discipline and a lot of typing to get them to do the simplest things.
- id: 1829
  author: stalepie
  author_email: stalepie@hotmail.com
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: I refuse to install on Java.
- id: 1830
  author: kshitij
  author_email: kslauria@gmail.com
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    It's not even a theoretical situation that you *may* have to deal with: C was my first language, and a couple of weeks ago, boy was I glad I knew it. I'm taking part in the national round of the World Robotics Olympiad, and the Lego graphical programming language is six shades of pathetic. What's a man to do then? Use *Lua*, of all things? Or maybe, if such a thing exists, use a Python port? There's a Java port, I know, but I'm competing on a national level with hardware that's as powerful as a desktop twenty-five years ago.

    But I still love making Lego robots, and I still love programming them. You know why? Because when the shit hits the fan, the C-programmer hits the metal (to mix metaphors :) ), and the comfort and ease of using a powerful, platform-agnostic, fast-as-hell and, most of all, *down-to-silicon* language is beyond words.

    Hell, I can tell any number of C-saved-my-ass stories. Typical example: I was playing with Mandelbrot and Julia sets, and, naturally, I wrote the code in Python. Once it was debugged and running nicely, and I had made a dozen different colouring schemes, I wanted to render a couple of images in extremely large resolutions, just to check them out, and maybe take prints if I felt like it.

    Unfortunately, it was pathetically slow. I was using PIL, which is generally accepted to be pretty fast, and I wasn't doing anything stupid -- the suggested method for building up images pixel-by-pixel was to generate a native list and export to image only at the end, and I timed several approaches and this *was* the fastest. At this point, I had two choices: delve deep into PIL and Python internals to optimize, or rewrite in C.

    I got a ~30x speedup. With the same algorithm. Even the same *code*, the inner loops, at least.

    If you don't know C, you're missing out on the pure, unadulterated pleasure of *fast*, *lean* and *fucking awesome*.
- id: 1831
  author: john naglick
  author_email: ''
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    Good blog.

    I completely agree that knowledge of C is essential for all programmers. It's analogous to knowing calculus for doing high level math: sure, calculus may not have a direct and/or obvious application to every specific area of high-math, but it is so fundamental that without it, your understanding will always be limited. C is the base on which true software development knowledge is built.
- id: 1832
  author: Greg
  author_email: ''
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: 'Pfft.  There are plenty of languages out there that you can get all the
    performance you need, without all of the cruft and bugs of C.  In no particular
    order: D, Cyclone, Clean, and ML to name a few.'
- id: 1833
  author: Nosredna
  author_email: rhettanderson@gmail.com
  author_url: http://dreaminginsoftware.com
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    I want the programmers I work with to have, at some point, have written something big in C, and something medium-sized in assembly.

    Otherwise I can't trust them.
- id: 1834
  author: Ron
  author_email: ''
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: Greg, you're not getting it. This is not about performance. This is about
    low level and that it's the basis of too many vital things (especially when it
    comes to operating systems) to just ignore it.
- id: 1835
  author: Mike
  author_email: tutufan@gmail.com
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    I don't use C very regularly, as I find that a higher-level language like Python is the most appropriate for most of the things that I do.  Nonetheless, I can't imagine hiring anyone not competent in C for any but the most trivial programming job.

    (C++ is another beast entirely, and I have very mixed feelings about it.  That notwithstanding, obviously there's a C-ish subset of C++ that has similar properties.)
- id: 1836
  author: Jes
  author_email: jestertru@gmail.com
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    There are plenty of things to dislike about C but it's an amazing link to the underlying reality of computing.  I can't imagine anyone understanding the majority of computing (and certainly not hardware) without it.  That includes compilers completely.

    I'm old enough to have learned 8080/Z80 assembly long before I learned C so the connection between the two is a bright line for me at a deep intuitive level.  I also was damaged by FORTRAN and BASIC (there weren't many other languages broadly available to folks who weren't in corporate or academic data centers back then!).

    I had classes in C but it only really clicked when I turned on the flag to generate assembly and saw how the code got translated.   It will make you a very good, defensive C programmer to learn that way.  It also carries over to other languages when you know what the inherent limits are of the hardware and how it implements various software constructs.   This link is most transparent in C.

    I'm still involved in microcontrollers (which is where you can live the incarnation of the 1970s/1980s when you did both assembly and C as mainstream computing skills) which is dominated by C and assembly still - you simply don't have the stack and heap sizes to implement high level languages in most cases.

    Yes, I love ruby, python, et al. when I can use them.  And it's both the syntax and the features that kick C's butt in some cases.  In general, no one language can be all things to all people and all applications all the time.  It's the simple, uneducated mind that thinks otherwise.
- id: 1837
  author: Kia Kroas
  author_email: kiafaldorius@gmail.com
  author_url: http://www.kiakroas.com
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    Greg, I must disagree, particularly with the last two--Clean and ML. Although I have no experience with them, a quick search reveals that they are functional programming languages influenced partially by Haskell. I would like to see a "Hello World" written in those two languages that can run on as many different processors as C. Heck, I doubt they can even be compiled.

    As for D and Cyclone, they've yet to stand against the test of time. D looks promising, but it still has pitfalls and kinks to work out. Last I checked, the stable release was still 1.x

    It's sad to see people ignore Assembly implementations and algorithms, but I can understand their pain. I gave up Assembly when the 64 bit processors (and multi-threading) started becoming popular. You have no idea how hard it is to maintain "modern" Assembly code. Also, getting some code written in asm to run on a different processor requires almost a complete rewrite, while in C you just cross-compile. Nowadays, I'm glad just to see snippets of bytecode in C programs. Better than nothing.
- id: 1838
  author: Daniel Pietraru
  author_email: daniel@littletutorials.com
  author_url: http://www.littletutorials.com
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: One of the biggest advantages of knowing C is that it forces you to really
    understand how the machine works. C was called a high level assembly language
    and the nickname it is right. With C you have almost absolute power over the machine
    and you can embed assembly language code in your C code to get absolute power.
    As with any absolute power comes a great deal of responsibility. And this teaches
    the programmer humility. Programmers who don't manage to "get it" migrate to other
    languages to escape. Programmers who "get it" go to other languages with a deep
    understanding of what programming is. I see lots of programmers, who never used
    C for anything serious, programming in high level languages and lacking even the
    basic understanding of what they do to the machine with their programs.
- id: 1839
  author: Scott
  author_email: dr3d@hotmail.com
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    Well, Ive been programming 31 years. Started programming C in 1975 at the Children's Museum in Boston after they got the first Unix license, so I can safely say I've used it longer than anyone else. These days and for the last 10 years or so, I never have any occasion to even look at C code. C++ sometimes, but high level object-oriented and scripting languages are my stock.

    The value to me in knowing C was seeing how it got translated into assembler and learning ways to write smarter code sequences. I'm not so sure you need to know C to understand these idioms today, however.

    So I am less sure that most that I would recommend anyone learn such an old language. You aren't going to find many jobs listing C in the required skill set. I would instead suggest that you do a lot of different things, benchmark what you do when its important to make something run fast (which isn't always important). And repeat over and over a lot - experience is the best way to become a great programmer.
- id: 1840
  author: horia314
  author_email: horia314@yahoo.co.uk
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: C is a form of kung-fu
- id: 1841
  author: shiro
  author_email: ''
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: john, you may mistook marcus's point.   Feeling sad about C's still being
    used doesn't necessarily mean wanting to ignore low-level stuff.  There were commercial
    systems that had been written, from applications and compilers to the OS and device
    drivers, completely in high-level languages other than C.  A little bit of assembly
    for bootstrap, maybe, but everything else is HLL and no C.   I absolutely agree
    to the original article here in a sense that every developer must understand how
    the systems below---OS and runtime---works, and must be fluent in the language
    in which the system is written, but the fact that the language is C is more like
    by chance of history.   (Of course, I don't deny that C's *the* language now.   Will
    it be so in future?   I hope not.)
- id: 1842
  author: Jeremy
  author_email: ''
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    And what about assembly and machine code and understanding machine architectures?

    Please find a new argument. This one is stale.

    C is an architectural niche. It's for places where one has to optimize code to a such a degree because the hardware limitations require it. (Although Moore's Law works towards making niche optimizations pointless)

    In the world of automobiles, C is the language of race car drivers. Not the every day motorist. As a Motorist, you need to have a basic enough understanding of your car to appreciate that it needs to be serviced regularly and understand what the interfaces tell you about the health of your vehicle. As a Driver, the focus should always be on the road. A system that is becoming more and more complex navigate as time goes on.

    The likes of higher level languages concern themselves with higher level concerns. Software architecture. Business models. Making code maintainable and readable and secure. Building systems that scale to consumer demand and make distributed/multithreaded code manageable.

    Even in the C/++ bastion of video game coding, I see high level langauges find their way into code: C#, LUA, Actionscript. It's easier to manage and maintain. One can respond to the demands of the consumer better when one can refactor/rewrite/maintain code faster and more effectively.

    I'm getting sick and tired of people justifying reinventing the wheel.
- id: 1843
  author: Ryan McGovern
  author_email: ryan.mcgovern@lerao.com
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    Scott,
    I disagree with your last comment that you would not see many jobs requiring C in their skill set.
    Having just gone through finding a new job though al-lot want Java skills a large number like to see C/C++ skills primarily for the insight it generates.  Also a large number of jobs are opening up for mainframes because of the retiring of mainframe developers this is meaning that GASP even Assembler programs need to be maintained.

    The biggest problem i see in programing is the fact that when it was done primarily by engineers it was treated more rigorously than it is today.  This is why i think the old programs in COBOL and C and Assembler that some companies still rely on have not been replaced.  When i was at GE they tried to replace the mainframes many times and failed each time to get software that was robust enough.
- id: 1844
  author: nathaniel
  author_email: taumeson@gmail.com
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    kshitij said:

    <i>...World Robotics Olympiad...Lego graphical programming language...Mandelbrot and Julia sets...</i>

    This is what you reference in your defense of C?  These are pursuits that don't translate to the real world.  My knowledge of robotics or fractal math have 0% bearing on creating workable software that contributes to my company or to society at large.

    Or, what Jeremy said:

    <i>The likes of higher level languages concern themselves with <b>higher level concerns. Software architecture. Business models. Making code maintainable and readable and secure. Building systems that scale to consumer demand and make distributed/multithreaded code manageable.</b></i>

    THIS. The world of software is SO MUCH MORE than what C offers you.  Nobody can convince me that C is "essential" anymore for the same reason that I don't have a butter churn, washboard, or carburetor. I would MUCH rather have developers working for me that are able to deal with distributed, scalable, secure systems.
- id: 1845
  author: Eric
  author_email: ''
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: I work at a large, well-known e-commerce company. We have a large legacy
    codebase written in C++. We also have a lot of newer code that's been written
    in Java. On the whole, the old C++ codebase is a complete mess. It's obtuse and
    extremely difficult to work in. And I don't really care whether it's something
    inherent to the language itself, or whether it's due to our dev's just not knowing
    C/++ well enough, the fact of the matter is that Java presents far less risk,
    costs less to develop, reacts to change much more easily, and serves the needs
    of the business first - not the needs of the hardware. And unless your business
    and hardware needs are linked (i.e. game development, OS development, etc), I
    see no reason to choose C/++.
- id: 1846
  author: Andrew
  author_email: ''
  author_url: http://andrew.nelless.net
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    Scott said:
    > Blockquote
    So I am less sure that most that I would recommend anyone learn such an old language. You aren’t going to find many jobs listing C in the required skill set.

    I would have thought that this is because C is now regarded as last weeks bread and butter. This knowledge should be latent in any applicant to any programming role. It isn't listed, not because because these skills aren't important, but because any developer, whether he or she be armed with C++, C# or Java, should have a working knowledge of C already.

    It would be like saying you have a Provisional when you already have a driving license, a car, insurance and have been driving incident free for 10 years.
- id: 1847
  author: Joe Chung
  author_email: jchung2007@gmail.com
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    There are better languages than C.  There are weaknesses in the language which are responsible for programmer errors, many of which have dire consequences (buffer overflow), and which make many optimization techniques impossible (pointer aliasing, mutable data structures).

    Ubiquity is a weak argument for quality.

    C is the best programming language... for C programmers.  There are better alternatives for everybody else.
- id: 1848
  author: Fabien
  author_email: blogs@x.edulang.com
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    Right now lots of code is written in C. Heck, nearly all that counts in Linux is written in C! It may be sad, but it's true. So, knowing a bit of C gives you the power to understand that code and interact with it.

    Recently I needed a very fast way to read 30,000 JPEG files (for a total of 8 GB), and get only the luminance. No big deal: libjpeg + a very thin wrapper. Nothing clever in there, just a few lines of code, but had I known nothing about C, I wouldn't have had access to this solution.


    Of course, the "near-assembler" argument still holds true: having coded (a bit) in C, when I use a higher-level language (including C++), I know what happens under the hood... and I'm grateful I don't have to do it by hand :-)


    Knowing C is definitely a good thing; actually coding awhole program in C seems masochistic to me.
- id: 1849
  author: Anonymous
  author_email: ''
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    "Why do I have to know what a wheel is? I just want to learn to ride a skateboard."

    Oddly, that's good enough for a lot of programmers, including me. I make good money with my "skateboarding" skills writing business applications for a manufacturing company.

    I can do this the rest of my life. I will never need to know C.

    If you were to say I *do* need to know C, that'd be like telling a surgeon he needs to understand organic chemistry. There's is simply no need. A surgeon doesn't engineer drugs. He slices and dices.

    I don't engineer drivers, databases, operating systems, imaging software or anything like that. I just slice and dice business logic.

    That being said, I agree with the author that C is a very important language. I just don't need to know it to get my job done.
- id: 1850
  author: Greg Herlein
  author_email: gherlein@herlein.com
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    C is a great language for writing code on small target systems.  C is a great language for writing operating systems.  C is a great language for writing high performance system level applications (especially for low-latency high throughput networking).  These are places where other language *can* be used (except for embedded perhaps).  But just look at the world:  most embedded systems are in C.  Linux itself is in C.  Apache is in C.  Oracle is in C (mostly, so I hear from buddies who work there).  MySQL is in C.  MPlayer is in C.  There's good reasons for that.

    Does this mean all code should be written in C?  No.  I manage two development teams and they rarely if ever write anything that's not Java or PHP.  Java is the core of all our new code - for the same reasons mentioned in many places above.  For our business we can deliver value fastest at the lowest cost by using Java.  Java developers are easier to find.  Java developers are fairly productive (measuring function points per unit time) - the language features (garbage collection etc), the tool chain, the availability of libraries, the automated build environments, the stability of the language ecosystem all together makes for a good business decision - for us.  I hear associates in other companies saying the same about Python - for their business.   The language preference is driven by the business environment.

    If we were building a low cost high performance embedded system we'd be coding in C (or maybe C++).  The language preference is driven by the business environment.  If you are building a new web service/web site and want to get to market as fast as possible then RoR is likely a good choice.  It's about the business no matter what young developers *like* in the way of a language.  It's not about intellectual purity, it's about BUSINESS.

    If you are scratching your own itch you can pick based on your own business environment:  which is whaterver you want it to be.   That's one of the best reasons to *do* side projects - to play and learn new languages and such.  Then you have the knowledge to apply to the next business scenario where you might get a big advantage from the modern language.

    But, I agree with the premise that understanding the way the machine works makes for a better programmer.  I don't care if you learned that by learning C.  I do care that you know it.  I won't enumerate all the core knowledge I look for - but things like how pointers really work, stack vs. heap, etc - are things that a developer needs to grok to write performance code in our environment.  If all you ever learned is Java then you probably don't know enough to hold your own on my teams.  You are probably fine elsewhere - in a J2EE shop or someplace high level - but not for our products.  Not for the problems we deal with.  But like I said, the language preference is driven by the business environment.  So too for the desired skill set.

    One size does not fit all.  I think it's rather unwise to assume that there are better languages for everyone that isn't already a C programmer.  That's a narrow view of the problem space.
- id: 1851
  author: kL
  author_email: a@b.com
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    and C is not that hard (development of big systems may be devilishly hard, but the basics of language itself are simple).

    but I'd skip C++ entirely. There are better object-oriented languages that don't have that much cruft and quirks (even in the C family: D and Objective-C). And if you want to just learn object-oriented programming, you can go for anything high-level (SmallTalk, maybe Java or C#).
- id: 1852
  author: Alastair
  author_email: alastair@girtby.net
  author_url: http://girtby.net
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    A snippet like this is really worthy of posting on reddit? Wow, must be a slow news day over there...

    I have to say that I'm amazed there are still people who don't seem to get it. This is an argument about the *ubiquity* of C, independent of its merits (or otherwise). Very simply: C is everywhere, so you should know it. If all the world's operating systems were written in COBOL I'd be arguing to learn *that* instead.

    By the way, C++ is a completely different beast, and I have an upcoming <del>snippet</del> article to address that.
- id: 1853
  author: Chris
  author_email: chris@hotmail.com
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: I wish I still had to use C. It's been 6 years since I began developing
    on the .NET platform, and I've yet to need to deep dive into anything that required
    writing in C. That may be a product of my position, however; I'm writing distributed
    enterprise applications where the architecture and design, in my belief, takes
    a lot more skill than knowing how to stuff registers for quicker algorithms.
- id: 1854
  author: Alex Drummond
  author_email: ''
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    > Greg, I must disagree, particularly with the last two–Clean and ML. Although I have no experience with them, a quick search reveals that they are functional programming languages influenced partially by Haskell. I would like to see a “Hello World” written in those two languages that can run on as many different processors as C. Heck, I doubt they can even be compiled.

    ML predates Haskell. As a matter of fact, both languages have extremely good compilers, as you could have discovered with a few minutes googling.
- id: 1855
  author: Andreas Schipplock
  author_email: andreas@schipplock.de
  author_url: http://schipplock.de
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    C is easy to learn and I don't get all the people out there pretending it's a sooo damn hard language. It's not.
    C is not only easy. It's also very old and most people use it because there is no other way. They are used to it and it would just take too much time to port existing code to another language. But that doesn't implicitly mean that this language is the optimum. It's by far not the optimum.
    What's interesting here is that many languages that appeared after C have a similar structure and syntax. They all tried to improve C in some way and if you know C you already know the basics of $language (replace it with java, c#, php, perl, pike, whatever...). But you have to learn the improvements of $language.

    And yes, you have to know C when you want to "hack" the linux kernel e.g. but what's the real base for this discussion here then? Of course you have to know C to hack the linux kernel plus assembler (in certain cases).
    And when you have some microcontroller that can only be programmed using assembler or C...eh yes you have to use it! If it would provide a D runtime, then you'd probably choose "D".

    I always get the impression that people are going to think that C is a good language _because_ it's used in so many software products, applications etc...but if you are honest to yourself and think about C a bit more you might find out that it's a very old language and that people had no real choice back in time and as I mentioned before it takes a lot of time, effort and conviction to port existing code. You can't really change people's mind who started coding in C for 15 or more years ago. Why should they? But the century had changed since then. New people are on the floor. People who grow up with another language. Why shouldn't they allowed to stick with it like all other C devs before ;). [joke]Ah, sure...they have to tidy up the mess the C devs did before :P [/joke].

    Don't get me wrong guys...I like C but I dislike the guys forcing it to be used everywhere not accepting that other higher level languages may replace it in many areas where it is practical.
    And what nobody directly mentioned before is $$$. Time is money and I can't tell my capitán that I'll need an additional week because I want to make the software finish a certain procedure in 10 seconds earlierer where the total time is 5 minutes or similar (choose yourself).
    I know that there are areas where such optimizations are necessary but in general? no, possibly a "no".

    So do I really have to _know_ C? Regrettably <strong>yes</strong>.
    So do I really _have to use_ C? Fortunetaly <strong>no</strong>.

    Kind regards,
    Andreas Schipplock.
- id: 1856
  author: David Silver
  author_email: ''
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    I've developed in primarily in C++ and Java, plus Python, Bash shell scripts and a bunch of other language.  I agree with you: **C is essential**.  Just look at the \*N\*X man pages or the Windows API documentation: C is the *Lingua Franca* of that documentation.

    Knowing C is **good for you**, because it gives you a **realistic mental model for how your code will execute and perform**.  I have seen some truly atrociously inefficient code written by people who have absolutely no understanding of how well a modern CPU should perform.  I am talking about code that was thousands, and in some cases tens of thousands of times slower than what was possible (and needed) - I know, because I rewrote it.  The authors of the slow code just shrugged and said they weren't sure how fast it should go.

    I would take your thesis one step further and state that **knowing at least one assembly language** (and these days, x86 is *everywhere*) is essential to forming a good mental model of how programs execute, and makes one a better programmer.
- id: 1857
  author: Fabien
  author_email: blogs@x.edulang.com
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    Andreas Schipplock wrote:
    > C is easy to learn and I don’t get all the people out there pretending it’s a sooo damn hard language.

    Not sure whether you're serious or not. Let's take a basic exercise: read one line of text from the standard input, and pass that to a function. You don't know the line size beforehand.

    In C++, or most other languages, it's ridiculously easy:

    string s;
    if (getline (cin, s))
      {
       f (s);
      }

    In C, I must admit I have no clue how to do that. There's a dedicated function, gets(), to do that, which must not be used in any circumstances. There's the slightly better fgets(), which won't work directly since it needs to know the size of the buffer. And of course, in most cases, you have to allocate a buffer yourself, and know how to deallocate it.

    Now that's what makes me think it's a very hard language to write, while it's not a hard language to read.


    > So do I really have to use C? Fortunetaly no.

    I completely concur. Read C, don't write it!
- id: 1858
  author: Rob
  author_email: rob_belics@charter.net
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: I would never have thought anyone would ever have to defend C for any reason.  And
    I totally agree with David Silver about assembly language, also.
- id: 1859
  author: Aristotle Pagaltzis
  author_email: pagaltzis@gmx.de
  author_url: http://plasmasturm.org/
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    “The power of instruction is seldom of much efficacy except in those happy dispositions where it is almost superfluous.”
    —Edward Gibbon
- id: 1860
  author: Boston
  author_email: boston-low@hotmail.com
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: 'Fabien: thats a bit unfair... you''re pointing out a limitation of the
    library that C comes with, which can be easily extended.  The language itself
    is not at fault there.'
- id: 1861
  author: vahid
  author_email: vahid.rafiei@gmail.com
  author_url: http://zentux.blogspot.com
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    Hi guys,

    I'm a hardcore fan of C. I do love it. It's a very strong language, meanwhile, it's little, pretty, elegant and has a very clear syntax. The grandeur of UNIX has derived by the power of C.
    But C++ ? I can't stand. I don't know why, but regarding to OOP (and performance at the same time) I choose Object-C. C++ is far from original C !
- id: 1862
  author: jt
  author_email: jt@globo.com
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    Yes, C is everywhere. Is it because of C? No, it's because of the compilers.
    Is it a good thing that C is everywhere? Yes, in a way, it is. It would be better if, eg, Ada were everywhere, or Eiffel.
    Sadly, it's C. And so we're stuck with a glorified assembler.
- id: 1863
  author: Fabien
  author_email: blogs@x.edulang.com
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    Boston said:
    > Fabien: thats a bit unfair... you’re pointing out a limitation of the library that C comes with,

    Nope. I'm pointing out a limitation of the language: there is not "string" type, and you can't do one yourself. Same goes for arrays. Basically, you have to manage the memory yourself.

    Just try to write the same code in C, using whatever library you wish. (In fact, there might be a way: using a garbage collector.)

    Or try this one:

    string f (string a, string b) { return a + " and " + b; }
- id: 1864
  author: Andrew
  author_email: ozandrewl@gmail.com
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    > Basically, you have to manage the memory yourself.

    I expect that if that wasn't the case, Alastair would be recommending that you learn whatever language (assembler, most likely) that the memory **was** managed in.
- id: 1865
  author: Fabien
  author_email: blogs@x.edulang.com
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    > I expect that if that wasn't the case, Alastair would be recommending that you learn whatever language (assembler, most likely) that the memory was managed in.

    Yep, that's the point.

    I was answering the (false) statement "C is easy". C is not easy to learn, ans it's difficult to make a serious project in C, because you waste a lot of time in minutiae, and there's always a high risk of buffer overflows, memory leaks, etc.

    When you start learning C++, a good piece of advice is: make your own string (and/or array) class, so that you get the feeling of how it's done, and then discard it in favor of C++'s standard string.

    Alastair's point is the same: code a little bit in C, to get the feeling of how a processor works, and how other languages are implemented. You could, of course, choose assembler instead, but it's a bit more complicated.
- id: 1866
  author: Zinghus
  author_email: ''
  author_url: http://as1.servebeer.com
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    Oh, please. Let the poor naive souls live in their java world: they are probably right, in their own personal way. C is for dinosaurs: who cares if the dinosaurs are ruling the world?

    C-aware people this way would have a real-programmer aura on them, good for us. Let's not forget it's the same aura fortran and assembler people enjoyed for years.
- id: 1867
  author: steve
  author_email: steve@adam.com.au
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    If you have an opinion about C, you're not qualified to comment. Program in C before you have opinions. If you program in Java or Perl or PHP or any other scripting tool, then yes, you are programming. But you're not programming computers, you're programming virtual machines that paper over the problems and defects of real computers.

    If you're in the webby world, you've already thrown away so much that the language you use is a minor consideration and you should therefore choose something easy. If you're programming hardware, like the Apple iPhone, then limited battery, limited CPU and limited resources mean you can't afford to piss away 2/3rds of what you have before you've even started.

    C has problems because the real computer has problems. There are no better languages, because they're creating virtual machines that don't have problems. Papering over the cracks has its cost, and sometimes you can't afford to pay those costs.

    However, let's make this clear. If you don't know C, you're Mistah Web 2.0. Please understand this and stop grabbing at the words "real programmer" as though you're in the same ballpark. It's nothing to worry about... John Resig programs in Javascript, and he's bloody amazing. So is Douglas Crockford.
- id: 1868
  author: brad
  author_email: noemail@email.com
  author_url: ''
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    > Some of the criticism of the Blogging Horror article was based on my insistence that knowledge of the C language is essential for all software developers.

    I don't get it. If you were WRONG, why still defend? It won't make things right anyway...

    > So can you as a developer choose to ignore it? Live in high-level language land for your entire career?

    Yes, definitely!

    > I would say almost certainly not.

    Maybe for you but for others it's their preference NOT yours?

    > High-level languages often provide abstractions that relieve you from the burden of dealing with the platform on which you’re building. Which is great, but sooner or later a crack is going to open up and the abstraction is going to leak.

    No it's not. What is a burden is to use C for creating ASP.Net applications or whatever...

    > Some day you’ll need to go spelunking into the depths of your runtime environment. Maybe you’ll need to call some other C-based API for which you don’t have a convenient wrapper in your high-level language of choice. Like, say, mmap-ing a part of a file instead of the whole thing. Or maybe you’ll just want a bit of a performance boost. And on that day, boy will you wish you knew C.

    No, not all applications has that requirement. That is why we choose what language is appropriate before we start on a project?

    > It’s for this pragmatic and entirely non-bigoted reason that I promoted C to the top of my language pantheon.

    Sure.

    > If you’ve never learned C, it means you’ll never be able to delve too deeply into the foundations your programming environment and find out exactly what is happening under the surface, or to extend it in any way.

    Oh, really?! And what makes you so sure that what you're saying is 100% true?
- id: 1869
  author: Aristotle Pagaltzis
  author_email: pagaltzis@gmx.de
  author_url: http://plasmasturm.org/
  date: '2008-08-23 11:19:00 -0500'
  date_gmt: '2008-08-23 11:19:00 -0500'
  content: |-
    > > So can you as a developer choose to ignore it? Live in high-level language land for your entire career?

    > Yes, definitely!

    Sure you can ignore the machine model. You’ll never be very much good as a programmer, and you’ll almost certainly also be ignorant about your incompetence level as a programmer, but you *can* ignore it. You’ll just operate under a relatively low ceiling of achievement; there will be many problems you will have absolutely no capacity to solve.

    Of course just because I’m not a certified chef doesn’t mean I can’t cook my own meals, f.ex., and so if you are doing only boring stuff (and these days, most programmers kid themselves by thinking they are doing more than boring stuff, even the ones who *can* do more than boring stuff), your ignorance will not cause you trouble.

    > That is why we choose what language is appropriate before we start on a project?

    All abstractions. Even programming languages are leaky abstractions. All of them eventually expose you to the fact that your code is running on a computer built out of silicon, not some mathematical ideal of a computation machine. Your program runs slow or out of memory, you run into hardware bugs, etc. For sufficiently complex programs, this is always the case.

    Not everyone writes code complex enough to encounter these cracks in the high-level picture, of course. If you do, though, then not understanding the machine model itself makes the difference between being able to solve the problem or just giving up and saying it’s not possible. Giving up is not necessarily worse than being able to do it, of course.

    (But as I wrote in the comments to Alastair’s original article, I think C in particular is not that interesting. It is even better to know assembler, particularly if you also understand how parsers work. From that vantage, even C becomes a (not-quite-as-)high-level language. It doesn’t matter much *which* assembler, either; seen one, seem ’em all.)
- id: 2922
  author: Project Euler | John Ramey
  author_email: ''
  author_url: http://www.johnramey.net/2008/08/24/project-euler/
  date: '2009-03-11 12:06:06 -0500'
  date_gmt: '2009-03-11 01:06:06 -0500'
  content: |
    <p>[...] I was not too savvy with Python until now that I am restricting myself to using one and only one programming language for these problems; I have learned much about the language, and I&#8217;m quite impressed.  It is always great to have mundane aspects of coding shot into oblivion because they really just are not needed anymore: well, maybe some will continue to believe C is necessary for all. [...]</p>
---
Some of the criticism of the [Blogging Horror article](/archives/2008/5/22/blogging-horror) was based on my insistence that knowledge of the C language is essential for all software developers. Some even said I was "bigoted" for such a viewpoint, because there are many other worthy languages out there. And there certainly are. But they are not all created equal.

I had tried to explain my reasons for C's special place in my list, but maybe I was not clear, so let's try again.

Here's the thing: C is *everywhere*. Recently Tim Bray [made basically the same point](http://www.tbray.org/ongoing/When/200x/2008/06/18/In-C); all the major operating systems, all the high-level language runtimes, all the databases, and all major productivity applications are written in C. And there are many other categories of software that I haven't even mentioned, all written in C.

So can you as a developer choose to ignore it? Live in high-level language land for your entire career? I would say almost certainly not. High-level languages often provide abstractions that relieve you from the burden of dealing with the platform on which you're building. Which is great, but sooner or later a crack is going to open up and the abstraction is going to leak.

Some day you'll need to go spelunking into the depths of your runtime environment. Maybe you'll need to call some other C-based API for which you don't have a convenient wrapper in your high-level language of choice. Like, say, mmap-ing a part of a file instead of the whole thing. Or maybe you'll just want a bit of a performance boost. And on that day, boy will you wish you knew C.

It's for *this* pragmatic and entirely non-bigoted reason that I promoted C to the top of my language pantheon. If you've never learned C, it means you'll never be able to delve too deeply into the foundations your programming environment and find out exactly what is happening under the surface, or to extend it in any way.

Of course there are many other reasons to learn C, such as those discussed in comments previously, but this is main reason why it's on my essentials list.
