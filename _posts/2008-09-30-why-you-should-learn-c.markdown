---
layout: post
status: publish
published: true
title: Why You Should Learn C++
author: alastair
author_login: admin
author_email: alastair@girtby.net
author_url: http://girtby.net
excerpt: "Not all software development projects can sustain a reasonable living. Anyone
  who has worked as a professional developer will take this truth as self-evident.
  It's a sad occurance, but often developers for notionally worthy projects find themselves
  having to abandon their dreams and find gainful employment elsewhere. The failed
  startup and the abandoned open-source project are all-too-common manifestations
  of this.\r\n\r\nI don't have a solution for this problem, but I mention it in order
  to define a set P, which is the set of all software development projects that can
  sustain a reasonable living. Now let's divide P into the subsets I and B.\r\n\r\n\r\n"
wordpress_id: 3611
wordpress_url: http://girtby.net/2008/09/30/why-you-should-learn-c
date: 2008-09-30 11:29:00.000000000 -05:00
categories:
- Nerd Factor X
- Verisimilitude
tags:
- c++
- advocacy
- career
- subjective
- reddit fodder
comments:
- id: 1870
  author: Aristotle Pagaltzis
  author_email: pagaltzis@gmx.de
  author_url: http://plasmasturm.org/
  date: '2008-09-30 11:29:00 -0500'
  date_gmt: '2008-09-30 11:29:00 -0500'
  content: |-
    You are trying to sell me on C++ because I can find more interesting C++ jobs than Java jobs? Seriously?

    And C++ can be just as cool as Perl or Ruby? Because those languages are reducible to dynamic typing – and C++ has that! … *Seriously!?*

    Oh, right. Ulterior motive. I’m not on a different planet after all. Please, next time, just be honest and make it quick, OK? Insulting your readers’ intelligence is not the best way to ask something of them.

    PS.: if you spot a Haskell job, let me know.
- id: 1871
  author: Socrates
  author_email: socrates@athens.gr
  author_url: ''
  date: '2008-09-30 11:29:00 -0500'
  date_gmt: '2008-09-30 11:29:00 -0500'
  content: One can actually get a job programming Haskell? I thought the only practical
    way of using Haskell was talking on reddit about it...
- id: 1872
  author: Don Stewart
  author_email: dons@galois.com
  author_url: http://www.cse.unsw.edu.au/~dons
  date: '2008-09-30 11:29:00 -0500'
  date_gmt: '2008-09-30 11:29:00 -0500'
  content: |-
    Socrates, talk to these guys, http://haskell.org/haskellwiki/Haskell_in_industry

    Commercial Users of FP workshop was last week, http://cufp.galois.com, and there was no shortage of industrial users.
- id: 1873
  author: Gnardok
  author_email: gdok@gmail.com
  author_url: ''
  date: '2008-09-30 11:29:00 -0500'
  date_gmt: '2008-09-30 11:29:00 -0500'
  content: |-
    Yes you are correct in all your statements. I have found that of all the interesting programming jobs, C has the most in terms of algorithmic complexity and the mathematics involved. All the mindless shovel work has been moved to C++ land. C really is a better C++ and the people who say C++ is a superset of C is just plain wrong.

    The future is C99 and languages built on top of that(or maybe D). Like the Vala programming language. C++ will die and be the new Cobol.
- id: 1874
  author: Keep It Simple Stupid
  author_email: kiss_my_java_ass@hotmail.com
  author_url: ''
  date: '2008-09-30 11:29:00 -0500'
  date_gmt: '2008-09-30 11:29:00 -0500'
  content: |-
    hello, I enjoyed your article a great deal. However I disagree with you that people should be learning C++. Let me tell you why that is.

     (1) The language feature set is too complex for most developers to master - its not enough that some people nearer the extreme end of the austism-disorder-spectrum can do that

     (2) The language spans both high level and low level programming, and low level programming is rarely needed these days.

     (3) The language feature set is ill-defined (have you tried to disentangle the ISO spec?), implementations often vary and language feature interaction is resolved in arbitrary ways that you cannot guess, only learn.

     (4) The tooling support is necessarily limited by the complexity of the language - even modern tools struggle to provide the level of finesse seen in the managed language world.

     (5) Its too brittle - mistakes in C++ can and often do bring down the entire process. Mistakes in managed languages will often only bring down the current thread.

     (6) The performance advantages are subtle to judge and often non-existent

    In summary let us consider a developer to have a complexity budget, that budget can be spent on the problem domain or on the language. C++ consumes too much of that budget on itself.

    No, let us thank C++ for what it has taught us about software development, let us thank James Gosling and friends for stealing ideas and discarding others, and let us thank ourselves for being wise enough to draw a line and move on.
- id: 1875
  author: Socrates
  author_email: socrates@athens.gr
  author_url: ''
  date: '2008-09-30 11:29:00 -0500'
  date_gmt: '2008-09-30 11:29:00 -0500'
  content: |-
    No man undertakes a trade he has not learned, even the meanest; yet everyone thinks himself sufficiently qualified for the hardest of all trades, that of programming in C++. False words spoken by such men as "Keep It Simple Stupid" are not only evil in themselves, but they infect the soul with evil! And what is this greatest evil but that shameful ignorance of thinking that we know what we do not know?

    P.S: Thank you Don Stewart, I am once again reminded that the only thing I know is that I know nothing.
- id: 1876
  author: markus
  author_email: she@hotmail.com
  author_url: ''
  date: '2008-09-30 11:29:00 -0500'
  date_gmt: '2008-09-30 11:29:00 -0500'
  content: |-
    The job issue really is a totally different one compared to Ruby or Python, really. I find the syntax of the latter a lot easier than on C++, including what is going on.

    Now, difficult things in math will continue to be not easy, but the thing is - if you dont need superspeed or fiddle into ultimately low level, there simply is no need anymore to use C++. Just look at many games - they use C++ for the engine and often for example Lua as the glue. Why?

    Because Lua is easier to work with than C++.

    That the job situation differs does not mean much about the above fact.
- id: 1877
  author: Alastair
  author_email: alastair@girtby.net
  author_url: http://girtby.net
  date: '2008-09-30 11:29:00 -0500'
  date_gmt: '2008-09-30 11:29:00 -0500'
  content: |-
    > You are trying to sell me on C++ because I can find more interesting C++ jobs than Java jobs? Seriously?

    Yes. That has been my experience.

    > And C++ can be just as cool as Perl or Ruby? Because those languages are reducible to dynamic typing – and C++ has that! … *Seriously!?*

    No. I never said that.

    I'm not trying to insult your intelligence, please don't insult mine.
- id: 1878
  author: Platon
  author_email: hahah@gmail.com
  author_url: ''
  date: '2008-09-30 11:29:00 -0500'
  date_gmt: '2008-09-30 11:29:00 -0500'
  content: You C++ zealots remind me of old people bragging "Hey look I can still
    get an erection with this dick". The new standards are like viagra, it will work
    for a while but eventually your shitty dick will die. Stop patching it up and
    move on.
- id: 1879
  author: Lofi
  author_email: lofi@live.co.uk
  author_url: ''
  date: '2008-09-30 11:29:00 -0500'
  date_gmt: '2008-09-30 11:29:00 -0500'
  content: nurse!
- id: 1880
  author: Bill
  author_email: bill@gmail.com
  author_url: ''
  date: '2008-09-30 11:29:00 -0500'
  date_gmt: '2008-09-30 11:29:00 -0500'
  content: Ok C++ haters, put up or shut up - what are you writing that compares in
    interestingness with stuff mentioned above, and what language do you use?
- id: 1881
  author: G
  author_email: ''
  author_url: ''
  date: '2008-09-30 11:29:00 -0500'
  date_gmt: '2008-09-30 11:29:00 -0500'
  content: Nice artickle. My experience is exactly the same. I used to do some C#
    project because I wanted to be  part of the hype a bit. But have now given up
    on it. Mainly because of the lack of "I" projects. But also because it is hard
    to to top quality projects in it. As you said, C++ has a bad rep and some hard
    to master dark corners, and if you are not careful it will crash on you. But on
    the other hand if you are careful, it is a much better language for creating clean,
    welldesigned, stable, bugfree aplications than Java/C#/Dynamic whatever can ever
    aspire to be.
- id: 1882
  author: Aristotle Pagaltzis
  author_email: pagaltzis@gmx.de
  author_url: http://plasmasturm.org/
  date: '2008-09-30 11:29:00 -0500'
  date_gmt: '2008-09-30 11:29:00 -0500'
  content: |-
    > Yes. That has been my experience.

    My point is that this is a false dilemma. Sure, the bottom of the job barrel is almost entirely populated with Java, but that doesn’t mean finding interesting jobs requires C++. There are lots of other alternatives to being enterprisey.

    The other false dichotomy is that interesting jobs have to be algorithmically complex rather than focused on moving around data. There are lots of ways in the latter can be challenging: eg. try doing it at a torrential pace. (Of course, far fewer people need to do that than those who would like to think they need it. The majority of Java jobs, particularly, are indeed concerned with ways of moving data around that are boring.) As another example, my current project does involve CRUD with a (quasi-)relational database somewhere in there and forms that users are going to type things into. (And it’s not currently in need of massive scale.) So it would seem to fall neatly into your boring box.

    Except, it’s in need of extraordinary flexibility, so there’s a tree data structure for records in there along with a form of schemata that can be used for either validity checks or queries, depending on the context (eg. as validity constraint for inter-record links). In many ways it’s more akin to a semweb research project. Trees are also versioned, and as part of that I’m implementing fully-general XHTML diffing (though for presentation purposes only, not 3-way merge), which, astonishingly enough, no one else appears to have done – they all seem to have given up and picked an extremely reduced version of the problem instead (like converting HTML to plaintext in some marginally intelligent fashion and then diffing that). It’s also socially interesting: we’re trying to push a strongly wiki-inspired approach in the highly politicized medical sector (and we’ve boiled down the relevant wiki ideals as “collaborative peer review” for the purposes of conveying them to doctors, which seems to be working brilliantly, if I may say so) – and for all the annoyance of having to navigate politics, I feel we’re doing something with great potential for lasting importance.

    Oh yeah, and that’s all Perl and SQL. (Although we might move to a different kind of backend – some kind of graph storage, possibly, like maybe an RDF database. MonetDB has crossed our radar too. Matching a large pile of trees against a schema will be a ubiquitous operation, and it remains to be seen whether I can make that fast enough on top of an SQL database.)

    I hope you can see why your article might sound preposterous to someone.
- id: 1883
  author: Sunny Kalsi
  author_email: thesunnyk@gmail.com
  author_url: http://blog.quaddmg.com
  date: '2008-09-30 11:29:00 -0500'
  date_gmt: '2008-09-30 11:29:00 -0500'
  content: |-
    You seem to have provoked some violent reactions from this article, and I don't know why. You're not claiming that C++ is the greatest language in the world or anything like that. You're just saying that, pragmatically, if you're going to be doing something fun and be paid for it, chances are you'll be doing it in C++ (or be with an awesome company that let's you use something better).

    It's like you're promoting French with "better than English, and at least you're not speaking Klingon." I don't mind that. Speak French and start getting "paid and laid", as they say, as opposed to going all the way and speaking lojban or some crap and being a freakshow. Speak English and you're probably in a call center in India.
- id: 1884
  author: Alastair
  author_email: alastair@girtby.net
  author_url: http://girtby.net
  date: '2008-09-30 11:29:00 -0500'
  date_gmt: '2008-09-30 11:29:00 -0500'
  content: |-
    > The other false dichotomy is that interesting jobs have to be algorithmically complex rather than focused on moving around data. There are lots of ways in the latter can be challenging: eg. try doing it at a torrential pace.

    Actually I would say that a large volume of data that needs to be processed with either high throughput or low latency (or both) *does* require some attention to algorithms. The [Wide Finder](/archives/2008/7/3/wide-finder-2-the-widening) project was a good example of this.

    Your project sounds very interesting, have you considered C++ for the task? (joke)

    > I hope you can see why your article might sound preposterous to someone.

    Well, I guess so. I thought I had put in enough disclaimers about it being highly subjective, but apparently not.

    So just out of interest, of the interesting projects in your part of the world which are capable of providing a worthwhile income, what languages do you see being used? Is Perl all that common? (Because let me tell you it's certainly not around here...)
- id: 1885
  author: Aristotle Pagaltzis
  author_email: pagaltzis@gmx.de
  author_url: http://plasmasturm.org/
  date: '2008-09-30 11:29:00 -0500'
  date_gmt: '2008-09-30 11:29:00 -0500'
  content: |-
    > Actually I would say that a large volume of data that needs to be processed with either high throughput or low latency (or both) *does* require some attention to algorithms.

    Right, which was roughly my point.

    > Your project sounds very interesting, have you considered C++ for the task? (joke)

    (And I dutifully laughed.)

    > what languages do you see being used?

    Java and C# make up the crushing majority of jobs. Everything else is a niche language, even C++, although some niches are bigger than others and C++’s is quite roomy. Perl is common enough that I do not worry about having to switch languages to make a living, though.
- id: 1886
  author: steve
  author_email: steve@adam.com.au
  author_url: ''
  date: '2008-09-30 11:29:00 -0500'
  date_gmt: '2008-09-30 11:29:00 -0500'
  content: Objective C.
- id: 1887
  author: Yellow Pages guy
  author_email: eddiemoses81@yahoo.com
  author_url: http://www.onlinebizbuzz.com
  date: '2008-09-30 11:29:00 -0500'
  date_gmt: '2008-09-30 11:29:00 -0500'
  content: |-
    I love C++! Thanks for post.
    And yes, objective C is crucial nowadays for the iphone.

    Thanks
    edd
- id: 1888
  author: The truth
  author_email: lasecta_esclavo@hotmail.com
  author_url: ''
  date: '2008-09-30 11:29:00 -0500'
  date_gmt: '2008-09-30 11:29:00 -0500'
  content: |-
    I remember when the ASM programmers were saying "You should learn ASM, it will offer you more interesting jobs".

    Aaaaah, good times.
- id: 1889
  author: Aristotle Pagaltzis
  author_email: pagaltzis@gmx.de
  author_url: http://plasmasturm.org/
  date: '2008-09-30 11:29:00 -0500'
  date_gmt: '2008-09-30 11:29:00 -0500'
  content: Btw, it belated occurs to me to point out that the automatically generated
    slug for this article is suboptimal – a manually set “`why-you-should-learn-cpp`”
    would probably have been more appropriate than the “`why-you-should-learn-c`”
    transliteration of the article title.
- id: 2891
  author: Triodus
  author_email: accesstomypc@yahoo.com
  author_url: ''
  date: '2009-03-10 01:55:55 -0500'
  date_gmt: '2009-03-09 14:55:55 -0500'
  content: |
    <p>I've been coding last years in C# for the .NET platform (very good for multi-tier, business oriented apps). </p>

    <p>Recently, i had to write code that communicates directly with an hardware device. So i took my good'ol' C/C++ knownledge  and a VC++ compiler.</p>

    <p>How to tell.. You find yourself again writing RIGHT code, THINKING rather than trying and typing. It's really a great language, even if some others aren't bad.</p>
- id: 4285
  author: Unknown Programmer&#8217;s Blog &raquo; 10 reasons you should know C++
  author_email: ''
  author_url: http://www.unknownprogrammer.com/2009/10-reasons-you-should-know-c/
  date: '2009-05-20 20:33:32 -0500'
  date_gmt: '2009-05-20 09:33:32 -0500'
  content: |
    <p>[...] pointed out by Alastair Rankine in a post which I agree with, C++ projects are over-represented in the set of interesting projects and under-represented in the re.... All other things being equal, working on an interesting project instead of non-interesting one is [...]</p>
---
Not all software development projects can sustain a reasonable living. Anyone who has worked as a professional developer will take this truth as self-evident. It's a sad occurance, but often developers for notionally worthy projects find themselves having to abandon their dreams and find gainful employment elsewhere. The failed startup and the abandoned open-source project are all-too-common manifestations of this.

I don't have a solution for this problem, but I mention it in order to define a set P, which is the set of all software development projects that can sustain a reasonable living. Now let's divide P into the subsets I and B.


<a id="more"></a><a id="more-3611"></a>

#### The 010 Types Of Projects In The World

Let I be the subset of P that are Interesting projects. This is obviously a subjective criterion, but for the sake of argument I'm asking you to adopt my own definition. Interesting projects are characterised by being algorithmically complex, and performance sensitive. They possibly involve large amounts of data, or an intrinsically distributed problem domain, and almost always strongly linked to mathematics. In my time I have worked on some I-projects. Most recently: native-MPEG video splicing, network performance benchmarking, and real-time automated trading.

Let B be the complement of I. Again, I'll ask you to adopt my subjective definition. Projects in the B set are typically data-centric, focusing on moving a bit of data from one place to another. There's almost certainly a relational database in there somewhere. And probably a user interface with forms, into which mindless drones spend are to spend their days keying in meaningless data. It's called <acronym title="Create, Retrieve, Update, Delete">CRUD</acronym> for a reason.

In order to make B-projects at all tolerable for the developers, they are typically sexed up with the use of inappropriate technology. Enterprisey solutions emerge, gratuitously over-engineered in the hope that developers won't impale themselves on their own keyboards out of sheer boredom. It's a sure sign that architectural astronautics has hit reality-escape velocity when terminology is co-opted from Interesting projects; so there is probably a web services "stack" and a message service "bus" in there somewhere. But to those who care to cast a critical eye, these projects are simply moving data from one place to another, with very little transformation or aggregation or any other algorithmically tricky task required along the way.

#### The Developer's Dillema

So: you're a developer. The most recent rent cheque has bounced and you've finally admitted to yourself that you need to shelve your world-changing open source project and go out and find a paying gig. Which type of project are you going to look for?

"Well, der," you might think, having looked at the title of this article, "anything that *doesn't* involve coding in C++! That language is a [crock of shit](http://thread.gmane.org/gmane.comp.version-control.git/57643/focus=57918)!"

To which I say: not so fast there bub. I'm just going to put this out there; of the I-projects, that is projects that are interesting *and pay the rent*, a substantial proportion are written in C++. In other words, C++ is over-represented in the I-projects and under-represented in the B-projects.

<img src="/assets/2008/09/p-set.png" alt="Attempt at explaining it all with a venn diagram" title="p-set" width="312" height="233" class="size-full wp-image-3744" />

All of my recent I-projects have been C++ projects. So, whatever you may think about the merits or otherwise of C++ as a language, it has *great jobs*. Hey, if nothing else, you're not likely to have to deal with WS-*. This is a good thing.

This is a simplification: obviously the job involves more than just the project. You may have to deal with poor air conditioning, the [Virtual Furniture Police](/archives/2005/10/26/the-virtual-furniture-police/), obnoxious co-workers, or even (and I wouldn't wish it on my worst enemy) *commercial radio*. `<shudder/>`. For the purposes of this article I'm going to assume these inconveniences are more-or-less evenly distributed across the P set, with no net disadvantage to C++ projects.

Now in case I haven't sprinkled this post with sufficient disclaimers of subjectivity, let me make one more. This is all based on my experience of the developer job market, mostly here in Sydney. Your experience and opinions may differ, and good luck to you if they do.

#### The Rise and Purge of C++

C++ itself used to be fairly evenly distributed across the P set. There was a time when it was just the default language and, despite the compiler writers valiantly struggling to keep up with a rapidly &mdash; and imaginatively &mdash; evolving standard, it was still widely used on all types of P projects. Especially the B projects; C++ and its enterprisey friends like CORBA were the way that we sexed up our data-centric applications back in the mid-90s.

Then Java came along and everyone who worked on B projects got swept along with it. At the time Java seemed like a huge step forward and allowed us to soar to dizzier heights of architectural astronautics. All that CORBA, SOM, COM and other nonsense would be re-invented in Java land, this time with a vague chance that it might work. For whatever reason it seems that the I projects were less affected by the Java bombshell (or by mixed metaphors, for that matter).

So fast forward to the present day, and we have all sorts of dreary jobs hewing enterprisey architectures out of raw Java, or C#, or even VB.NET, whatever the hell that is. C++ is yesterday's news. The only projects still using it are, well, projects from the I set. Or, Dog help them, some projects still lumbering on from the 90s. You probably don't want to work on one of the latter, but you almost certainly *do* want to work on one of the former. Being able to tell the difference is obviously a pre-requisite before putting the C++-has-best-jobs idea into practice.

#### C++ : It's Not That Bad, Really

At this point you may well be thinking "well, C++ may be common amongst interesting projects, but only a few years ago you could say the same thing about FORTRAN, and I'd rather gouge my eyes out with a novelty mousepad than have to gaze upon code written in *either* of those languages!" And I sympathise with regards to FORTRAN, but modern C++ should not warrant such a reaction.

In 2001 a chap called Andrei Alexandrescu published a book called <cite>Modern C++ Design</cite>. Despite the ominous inclusion of "modern" in the title (to me that word always seems to denote the anachronistic), it was really groundbreaking and is still highly recommended reading. Alexandrescu showed the potential of the so-called generic programming style, which is enabled only when you have a truly powerful (albeit sometimes arcane) template system.

To those who, like me, struggled to use the early incarnations of generic programming, such as exhibited in the Standard Template Library, the book was something of a revelation. Today, the Boost libraries are enabling these idiom changes and in some cases going way beyond the potential glimpsed in <cite>Modern C++ Design</cite>. The result is that small-m modern C++, as exhibited by Boost itself, is *nothing like* the C++ of yore.

C++ has a bit of a bad reputation (as per the Linus quote above), and it is sometimes justified, but too often online I see noses turned up at C++ in favour of cooler dynamically-typed languages like Perl, Python and Ruby. But maybe this is based on an outdated perception of the C++ language, at least as it is practiced today, because you certainly [can use dynamic typing in C++](http://herbsutter.wordpress.com/2008/06/20/type-inference-vs-staticdynamic-typing/), for one thing.

I think it's fair to say that if you were designing a better C from scratch these days, you probably wouldn't end up with C++. But regardless of the mistakes made in the design of C++ &mdash; and I think the [C++ Frequently Questioned Answers](http://yosefk.com/c++fqa/) page captures most of them &mdash; I think the language has aged reasonably well. I'm certainly looking forward to C++0x, the next standard with many interesting features.

#### Spot The Ulterior Motive

To recap: there are many interesting projects in C++, and despite what you may have heard, it's really not that unpleasant to code in.

So, go learn C++.

If you already know it, then good news! There are great jobs around. Who knows, if you email me, I may be able to help you find one.
